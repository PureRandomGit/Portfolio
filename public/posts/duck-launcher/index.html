<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100..900;1,100..900&display=swap" rel=stylesheet><link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel=stylesheet><title>Duck Launcher | PureRandom.dev</title><meta name=keywords content="Robotics"><meta name=description content="Final project for UCF EGN 1006C."><meta name=author content><link rel=canonical href=http://localhost:1313/posts/duck-launcher/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.cc07872689f71785484391c657e6c3c93d8ab3149d610efb3345881f63c9f0ba.css integrity="sha256-zAeHJon3F4VIQ5HGV+bDyT2KsxSdYQ77M0WIH2PJ8Lo=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/assets/logo.svg><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/assets/logo.svg><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/assets/logo.svg><link rel=apple-touch-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/posts/duck-launcher/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="http://localhost:1313/posts/duck-launcher/"><meta property="og:site_name" content="PureRandom.dev"><meta property="og:title" content="Duck Launcher"><meta property="og:description" content="Final project for UCF EGN 1006C."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-11-21T00:00:00+00:00"><meta property="article:modified_time" content="2025-11-21T00:00:00+00:00"><meta property="article:tag" content="Robotics"><meta property="og:image" content="http://localhost:1313/duck.webp"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:1313/duck.webp"><meta name=twitter:title content="Duck Launcher"><meta name=twitter:description content="Final project for UCF EGN 1006C."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"Duck Launcher","item":"http://localhost:1313/posts/duck-launcher/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Duck Launcher","name":"Duck Launcher","description":"Final project for UCF EGN 1006C.","keywords":["Robotics"],"articleBody":" Duck Launcher Final At UCF every freshman engineering student is split into groups of four and tasked with designing and programming a TI-RSLK robot to score as many little rubber ducks in the “pond” as fast as possible by following a black line to the pond within 10 minutes.\nThe pond is a large pentagon in the middle of 5 tracks that teams are trying to score into. There are 3 zones in the pond, each getting progressively smaller and worth more points; 100, 300, and 500 respectively. There are also penalty cups closest to the black line that add a time penalty if hit, and bonus cups at the start line that can be hit on the way back for a 50 point bonus every time.\nDesign Our main design goal was to score in the 500 point section as quickly as possible. We really wanted to get cycle times to be as quick as possible since we were worried about the small size of the center 500 point ring filling up and preventing us from scoring all the points possible. Some constraints we had to follow were that the robot must be against the pond wall before shooting a duck and the motors on the robot were rather weak, making it essential we keep the weight of our mechanisms to a minimum. We also needed to hit the wall perfectly perpendicular to make aiming more accurate.\nAfter testing out several design archetypes we settled on a motorized lever arm. This allowed us to quickly shoot ducks as soon as we hit the wall of the pond and was overall a very lightweight and compact mechanism. To fix the aiming issue we added a front bumper that went over the front two bump switches that forced the robot to go flat against the wall. We ended up going through seven versions, tweaking various gear ratios and arm lengths before we finally settled on the model we used. Here is the link to the CAD for anyone interested: CAD Model - Onshape\nProgramming Every group was provided with very basic but working example code. However, this code was very messy and extremely slow which caused me to decide to rewrite it from scratch. One of the biggest issues with the example code is that they do not use a full PID, instead they just use a P value. While this works fine for the majority of robots, if you wanted to go faster than about 30% speed a true PID implementation is required.\nState Machine Architecture I structured the program around a state machine with six states: START, RESTART, PATH, SHOOT, TURN, and DONE. This made the code significantly cleaner and easier to debug which I will give credit to the example code for doing partially correct. Each state has its own dedicated function that handles exactly what needs to happen in that phase of the run.\nThe robot starts in START, waiting for a button press. Once triggered, it transitions to PATH where the line following happens. When the bump sensors detect the wall, it moves to SHOOT, fires the duck launcher mechanism, then enters TURN to do a 180-degree spin. After turning, it goes back to PATH to return home. On the second bump which is hitting the robot resetters hand for faster reset times, it transitions to DONE and waits for a restart by pressing the front bumper again.\nFull PID Implementation A proper PID controller is needed to consistently follow the line at faster speeds. The key improvement over the example code was using actual time deltas for the integral and derivative calculations rather than assuming a fixed loop time. We tuned our constants to KP = 0.05, KI = 0.001, and KD = 0.01 which allowed us to run at 90% motor speed while still tracking the line accurately. These values differed per robot as they all were in different states of disrepair so we were never able to tune the PID to be as smooth as I wanted.\nfloat dt = (currentTime - lastPIDTime) / 1000.0; // Convert to seconds int error = linePos - GOAL; float P = KP * error; integral += error * dt; integral = constrain(integral, -1000, 1000); // Anti-windup float I = KI * integral; float derivative = (error - lastError) / dt; float D = KD * derivative; float motor_speed_delta = P + I + D; The integral term includes anti-windup clamping to prevent it from accumulating too much error when the robot is off the line for extended periods. We also reset the PID state (error, integral, and timing) whenever transitioning between states to prevent any weird behavior from stale values.\nShooter Control The shooting mechanism was very simple, just a digital pin that triggers a relay to trigger the motorized lever arm. A quick HIGH pulse for 300ms is all it takes to launch a duck into the pond. I added small delays before and after to ensure clean activation and so that we don’t brownout the robot which was an issue we had when trying to run both the wheels and shooter motor at the same time.\nThe full code can be view here on my github: DuckLaucher\nIts not very pretty as a good bit of it was redone the day of the competition for a slight optimization in the PID. There is also a very basic score keeping webpage, its only slightly broken.\nRetrospective Overall we did great and I’m very proud of my team for coming first out of over two thousand freshman engineers! The average score was probably less than 2-3k which we crushed, scoring 30,500 points with 81 ducks (44 in the 500, 24 in the 300, and 13 in the 100).\nThere were a lot of cool and unique designs that I saw and we learned a lot about what works and what should be avoided. If we were to do this again there are several things we would change.\nFirst off, our fears of the center getting filled were confirmed, but not due to other teams—our cycles were so fast that the center was filled about 2-3 minutes into the competition. This caused a lot of ducks to bounce out of the center off of other ducks and land in the 100 and 300 point sections. We had nearly perfect accuracy so all the ducks from the score breakdown in the other sections are due to them bouncing out of the center. The best way to avoid this would probably be to fine tune the launch angle so that it either goes at a more downward angle to bounce up again or go at a very shallow angle so that the ducks hit the back wall of the 500 point zone and bounce inwards. This is similar to what our launcher did but it could be improved. Another way could be instead of launching the ducks, have a way to drop or place them in the center which would prevent them from bouncing out and make it so they can be stacked higher before completely filling it up.\nSecond, the PID tuning process could be improved. Ideally the PID should be tuned on a straight line at the weight of the final robot, and even better with the robot that is going to be used during the competition. Realistically the latter isn’t possible but the first two are very achievable and I am annoyed I didn’t think to just bring electrical tape to the lab and make a straight line for tuning.\nThe last thing is the line sensor is so close to the wheels that the PID needs to have higher than normal values to compensate for the short response time that’s needed. This isn’t as essential since we were able to run at 90% speed and most likely could have gotten that higher with more time spent tuning, but if it’s possible to move the line sensor forwards then do so.\nA fun bonus tip is to 3D print or buy a second wheel for the robot as they normally only had one and it makes it significantly more stable and accurate.\nVideo of our competition Links:\nCAD Model - Onshape\nDuckLaucher\nCompetition Video\n","wordCount":"1378","inLanguage":"en","image":"http://localhost:1313/duck.webp","datePublished":"2025-11-21T00:00:00Z","dateModified":"2025-11-21T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/duck-launcher/"},"publisher":{"@type":"Organization","name":"PureRandom.dev","logo":{"@type":"ImageObject","url":"http://localhost:1313/assets/logo.svg"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Home (Alt + H)"><img src=http://localhost:1313/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/about/ title=About><span>About</span></a></li><li><a href=http://localhost:1313/posts/ title=Posts><span>Posts</span></a></li><li><a href=http://localhost:1313/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Duck Launcher</h1><div class=post-description>Final project for UCF EGN 1006C.</div><div class=post-meta><span title='2025-11-21 00:00:00 +0000 UTC'>November 21, 2025</span>&nbsp;·&nbsp;7 min</div></header><figure class=entry-cover><img loading=eager srcset='http://localhost:1313/posts/duck-launcher/duck_hu_c28277569c1f6e38.webp 360w,http://localhost:1313/posts/duck-launcher/duck_hu_96a5c134ab4f7815.webp 480w,http://localhost:1313/posts/duck-launcher/duck_hu_62c529bbbcb99d0a.webp 720w,http://localhost:1313/posts/duck-launcher/duck_hu_1030f41e929bdb8b.webp 1080w,http://localhost:1313/posts/duck-launcher/duck_hu_78fbdffcfecf69a.webp 1500w,http://localhost:1313/posts/duck-launcher/duck.webp 2880w' src=http://localhost:1313/posts/duck-launcher/duck.webp sizes="(min-width: 768px) 720px, 100vw" width=2880 height=1620 alt="Duck Launcher Image"></figure><div class=post-content><hr><h1 id=duck-launcher-final>Duck Launcher Final<a hidden class=anchor aria-hidden=true href=#duck-launcher-final>#</a></h1><p>At UCF every freshman engineering student is split into groups of four and tasked with designing and programming a TI-RSLK robot to score as many little rubber ducks in the &ldquo;pond&rdquo; as fast as possible by following a black line to the pond within 10 minutes.</p><p>The pond is a large pentagon in the middle of 5 tracks that teams are trying to score into. There are 3 zones in the pond, each getting progressively smaller and worth more points; 100, 300, and 500 respectively. There are also penalty cups closest to the black line that add a time penalty if hit, and bonus cups at the start line that can be hit on the way back for a 50 point bonus every time.</p><h1 id=design>Design<a hidden class=anchor aria-hidden=true href=#design>#</a></h1><p>Our main design goal was to score in the 500 point section as quickly as possible. We really wanted to get cycle times to be as quick as possible since we were worried about the small size of the center 500 point ring filling up and preventing us from scoring all the points possible. Some constraints we had to follow were that the robot must be against the pond wall before shooting a duck and the motors on the robot were rather weak, making it essential we keep the weight of our mechanisms to a minimum. We also needed to hit the wall perfectly perpendicular to make aiming more accurate.</p><p>After testing out several design archetypes we settled on a motorized lever arm. This allowed us to quickly shoot ducks as soon as we hit the wall of the pond and was overall a very lightweight and compact mechanism. To fix the aiming issue we added a front bumper that went over the front two bump switches that forced the robot to go flat against the wall. We ended up going through seven versions, tweaking various gear ratios and arm lengths before we finally settled on the model we used. Here is the link to the CAD for anyone interested: <a href=https://cad.onshape.com/documents/fea657253e3efcf7a8011b18/w/9f6b0cfca8e076060c58e5d4/e/e4dd6842f8802302730311c8>CAD Model - Onshape</a></p><h1 id=programming>Programming<a hidden class=anchor aria-hidden=true href=#programming>#</a></h1><p>Every group was provided with very basic but working example code. However, this code was very messy and extremely slow which caused me to decide to rewrite it from scratch. One of the biggest issues with the example code is that they do not use a full PID, instead they just use a P value. While this works fine for the majority of robots, if you wanted to go faster than about 30% speed a true PID implementation is required.</p><h2 id=state-machine-architecture>State Machine Architecture<a hidden class=anchor aria-hidden=true href=#state-machine-architecture>#</a></h2><p>I structured the program around a state machine with six states: <code>START</code>, <code>RESTART</code>, <code>PATH</code>, <code>SHOOT</code>, <code>TURN</code>, and <code>DONE</code>. This made the code significantly cleaner and easier to debug which I will give credit to the example code for doing partially correct. Each state has its own dedicated function that handles exactly what needs to happen in that phase of the run.</p><p>The robot starts in <code>START</code>, waiting for a button press. Once triggered, it transitions to <code>PATH</code> where the line following happens. When the bump sensors detect the wall, it moves to <code>SHOOT</code>, fires the duck launcher mechanism, then enters <code>TURN</code> to do a 180-degree spin. After turning, it goes back to <code>PATH</code> to return home. On the second bump which is hitting the robot resetters hand for faster reset times, it transitions to <code>DONE</code> and waits for a restart by pressing the front bumper again.</p><h2 id=full-pid-implementation>Full PID Implementation<a hidden class=anchor aria-hidden=true href=#full-pid-implementation>#</a></h2><p>A proper PID controller is needed to consistently follow the line at faster speeds. The key improvement over the example code was using actual time deltas for the integral and derivative calculations rather than assuming a fixed loop time. We tuned our constants to <code>KP = 0.05</code>, <code>KI = 0.001</code>, and <code>KD = 0.01</code> which allowed us to run at 90% motor speed while still tracking the line accurately. These values differed per robot as they all were in different states of disrepair so we were never able to tune the PID to be as smooth as I wanted.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>float</span> <span class=n>dt</span> <span class=o>=</span> <span class=p>(</span><span class=n>currentTime</span> <span class=o>-</span> <span class=n>lastPIDTime</span><span class=p>)</span> <span class=o>/</span> <span class=mf>1000.0</span><span class=p>;</span>  <span class=c1>// Convert to seconds
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>error</span> <span class=o>=</span> <span class=n>linePos</span> <span class=o>-</span> <span class=n>GOAL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>float</span> <span class=n>P</span> <span class=o>=</span> <span class=n>KP</span> <span class=o>*</span> <span class=n>error</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>integral</span> <span class=o>+=</span> <span class=n>error</span> <span class=o>*</span> <span class=n>dt</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>integral</span> <span class=o>=</span> <span class=n>constrain</span><span class=p>(</span><span class=n>integral</span><span class=p>,</span> <span class=o>-</span><span class=mi>1000</span><span class=p>,</span> <span class=mi>1000</span><span class=p>);</span>  <span class=c1>// Anti-windup
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>float</span> <span class=n>I</span> <span class=o>=</span> <span class=n>KI</span> <span class=o>*</span> <span class=n>integral</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>float</span> <span class=n>derivative</span> <span class=o>=</span> <span class=p>(</span><span class=n>error</span> <span class=o>-</span> <span class=n>lastError</span><span class=p>)</span> <span class=o>/</span> <span class=n>dt</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>float</span> <span class=n>D</span> <span class=o>=</span> <span class=n>KD</span> <span class=o>*</span> <span class=n>derivative</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>float</span> <span class=n>motor_speed_delta</span> <span class=o>=</span> <span class=n>P</span> <span class=o>+</span> <span class=n>I</span> <span class=o>+</span> <span class=n>D</span><span class=p>;</span>
</span></span></code></pre></div><p>The integral term includes anti-windup clamping to prevent it from accumulating too much error when the robot is off the line for extended periods. We also reset the PID state (error, integral, and timing) whenever transitioning between states to prevent any weird behavior from stale values.</p><h2 id=shooter-control>Shooter Control<a hidden class=anchor aria-hidden=true href=#shooter-control>#</a></h2><p>The shooting mechanism was very simple, just a digital pin that triggers a relay to trigger the motorized lever arm. A quick HIGH pulse for 300ms is all it takes to launch a duck into the pond. I added small delays before and after to ensure clean activation and so that we don&rsquo;t brownout the robot which was an issue we had when trying to run both the wheels and shooter motor at the same time.</p><p>The full code can be view here on my github: <a href=https://github.com/PureRandomGit/DuckLaucher>DuckLaucher</a></p><p>Its not very pretty as a good bit of it was redone the day of the competition for a slight optimization in the PID. There is also a very basic score keeping webpage, its only slightly broken.</p><h1 id=retrospective>Retrospective<a hidden class=anchor aria-hidden=true href=#retrospective>#</a></h1><p>Overall we did great and I&rsquo;m very proud of my team for coming first out of over two thousand freshman engineers! The average score was probably less than 2-3k which we crushed, scoring 30,500 points with 81 ducks (44 in the 500, 24 in the 300, and 13 in the 100).</p><p>There were a lot of cool and unique designs that I saw and we learned a lot about what works and what should be avoided. If we were to do this again there are several things we would change.</p><p>First off, our fears of the center getting filled were confirmed, but not due to other teams—our cycles were so fast that the center was filled about 2-3 minutes into the competition. This caused a lot of ducks to bounce out of the center off of other ducks and land in the 100 and 300 point sections. We had nearly perfect accuracy so all the ducks from the score breakdown in the other sections are due to them bouncing out of the center. The best way to avoid this would probably be to fine tune the launch angle so that it either goes at a more downward angle to bounce up again or go at a very shallow angle so that the ducks hit the back wall of the 500 point zone and bounce inwards. This is similar to what our launcher did but it could be improved. Another way could be instead of launching the ducks, have a way to drop or place them in the center which would prevent them from bouncing out and make it so they can be stacked higher before completely filling it up.</p><p>Second, the PID tuning process could be improved. Ideally the PID should be tuned on a straight line at the weight of the final robot, and even better with the robot that is going to be used during the competition. Realistically the latter isn&rsquo;t possible but the first two are very achievable and I am annoyed I didn&rsquo;t think to just bring electrical tape to the lab and make a straight line for tuning.</p><p>The last thing is the line sensor is so close to the wheels that the PID needs to have higher than normal values to compensate for the short response time that&rsquo;s needed. This isn&rsquo;t as essential since we were able to run at 90% speed and most likely could have gotten that higher with more time spent tuning, but if it&rsquo;s possible to move the line sensor forwards then do so.</p><p>A fun bonus tip is to 3D print or buy a second wheel for the robot as they normally only had one and it makes it significantly more stable and accurate.</p><h2 id=video-of-our-competition>Video of our competition<a hidden class=anchor aria-hidden=true href=#video-of-our-competition>#</a></h2><div style=position:relative;padding-bottom:56.25%;height:0;overflow:hidden><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share; fullscreen" loading=eager referrerpolicy=strict-origin-when-cross-origin src="https://www.youtube.com/embed/T27N8VbtBpw?autoplay=0&amp;controls=1&amp;end=0&amp;loop=0&amp;mute=0&amp;start=0" style=position:absolute;top:0;left:0;width:100%;height:100%;border:0 title="YouTube video"></iframe></div><hr><p>Links:</p><p><a href=https://cad.onshape.com/documents/fea657253e3efcf7a8011b18/w/9f6b0cfca8e076060c58e5d4/e/e4dd6842f8802302730311c8>CAD Model - Onshape</a></p><p><a href=https://github.com/PureRandomGit/DuckLaucher>DuckLaucher</a></p><p><a href="https://www.youtube.com/watch?v=T27N8VbtBpw">Competition Video</a></p><hr></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/robotics/>Robotics</a></li></ul><nav class=paginav><a class=next href=http://localhost:1313/posts/bed-occupancy-sensor/><span class=title>Next »</span><br><span>Bed Occupancy Sensor</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=http://localhost:1313/>PureRandom.dev</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>