[{"content":" Goop\nHardware ESP32-C3 Super Mini Force Sensitive Resistor (FSR) 10K ohm Resistor 3D-Printed Case As I often use ESP32-C3 Super Minis in a lot of my projects due to their extremely small size I had already designed a slim case for them which worked prefectly for this application. The case can be found here on my MakerWorld Profile Page.\nWiring Software Using Esphome I wrote a basic yaml code to publish a resistor value as well as a binary occupancy value to HomeAssistant that can be found here.\n","permalink":"http://localhost:1313/posts/duck-launcher/","summary":"How we made the highest scoring duck launcher.","title":"Duck Launcher"},{"content":" Hardware ESP32-C3 Super Mini Force Sensitive Resistor (FSR) 10K ohm Resistor 3D-Printed Case As I often use ESP32-C3 Super Minis in a lot of my projects due to their extremely small size I had already designed a slim case for them which worked prefectly for this application. The case can be found here on my MakerWorld Profile Page.\nWiring The wiring was very simple, I just soldered one pin of the FSR to 3.3v and then the other pin to a analog pin, in my case pin 4, with the resistor connecting pin 4 and ground.\nSoftware Using Esphome I wrote a basic yaml code to publish a resistor value as well as a binary occupancy value to HomeAssistant that can be found here.\n","permalink":"http://localhost:1313/posts/bed-occupancy-sensor/","summary":"Low cost bed occupancy sensor made with an esp32-c3 super mini and a $10 resistor.","title":"Bed Occupancy Sensor"},{"content":" I wanted an automated blind solution that wouldn\u0026rsquo;t rely on cloud services or expensive commercial products. By repurposing an IKEA roller shades and designing my own controller system, I was able to build a cheap local solution.\nHardware The smart blind consists of four main components:\n28BYJ-48 stepper motor ULN2003 stepper motor driver board ESP32 microcontroller IKEA roller shade I chose these because they were very cheap off of Amazon or Aliexpress and because the ULN2003 was supported by Esphome\u0026rsquo;s stepper component which I was planning on using to program the esp32.\n3D-Printed Case To mount and house the motor and eletronics I designed a 3d printed case in Fusion360. This was my first time cading gears so it took me a bit to get the correct gear ration that would allow the motor to have enough torque to raise the blinds without skipping. After that it was just a matter of blocking out where each component would go and build the case around them.\nWiring The wiring for the ULN2003 was rather straight forward and only needed 4 wires connected to the esp32 and then power and ground for both the driver and esp32\nSoftware To test that everything was working I wrote a quick arduino program to spin the motor in both directions for a few seconds. After confirming my wiring was correct and the code ran I started to write the Esphome code. During this process, I discovered that RoadKillUK had published a Github that was very similar to what I was trying to accomplish. I only had to modify the code slightly to work with an esp32 but it was pretty much perfect.\nUsage \u0026amp; Future Improvements I\u0026rsquo;ve been running the blind for a little over a year now and have had no issue with it so far. There are a few things that I would change if I made a second version. First, the blinds are slow, they take over a minuet to raise/lower about 3 feet. Second, the stepper motor loses its memory of the blind position if it loses power and will need to be re-homed.\n","permalink":"http://localhost:1313/posts/smart-blinds-v1/","summary":"Cheap, simple and effective smart blinds made from and old IKEA roller shades and a few electronic components.","title":"Smart Blinds"},{"content":"I’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\nMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003eI’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\u003c/p\u003e\n\u003cp\u003eMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\u003c/p\u003e","title":"About"},{"content":" Goop\nHardware ESP32-C3 Super Mini Force Sensitive Resistor (FSR) 10K ohm Resistor 3D-Printed Case As I often use ESP32-C3 Super Minis in a lot of my projects due to their extremely small size I had already designed a slim case for them which worked prefectly for this application. The case can be found here on my MakerWorld Profile Page.\nWiring Software Using Esphome I wrote a basic yaml code to publish a resistor value as well as a binary occupancy value to HomeAssistant that can be found here.\n","permalink":"http://localhost:1313/posts/duck-launcher/","summary":"How we made the highest scoring duck launcher.","title":"Duck Launcher"},{"content":" Hardware ESP32-C3 Super Mini Force Sensitive Resistor (FSR) 10K ohm Resistor 3D-Printed Case As I often use ESP32-C3 Super Minis in a lot of my projects due to their extremely small size I had already designed a slim case for them which worked prefectly for this application. The case can be found here on my MakerWorld Profile Page.\nWiring The wiring was very simple, I just soldered one pin of the FSR to 3.3v and then the other pin to a analog pin, in my case pin 4, with the resistor connecting pin 4 and ground.\nSoftware Using Esphome I wrote a basic yaml code to publish a resistor value as well as a binary occupancy value to HomeAssistant that can be found here.\n","permalink":"http://localhost:1313/posts/bed-occupancy-sensor/","summary":"Low cost bed occupancy sensor made with an esp32-c3 super mini and a $10 resistor.","title":"Bed Occupancy Sensor"},{"content":" I wanted an automated blind solution that wouldn\u0026rsquo;t rely on cloud services or expensive commercial products. By repurposing an IKEA roller shades and designing my own controller system, I was able to build a cheap local solution.\nHardware The smart blind consists of four main components:\n28BYJ-48 stepper motor ULN2003 stepper motor driver board ESP32 microcontroller IKEA roller shade I chose these because they were very cheap off of Amazon or Aliexpress and because the ULN2003 was supported by Esphome\u0026rsquo;s stepper component which I was planning on using to program the esp32.\n3D-Printed Case To mount and house the motor and eletronics I designed a 3d printed case in Fusion360. This was my first time cading gears so it took me a bit to get the correct gear ration that would allow the motor to have enough torque to raise the blinds without skipping. After that it was just a matter of blocking out where each component would go and build the case around them.\nWiring The wiring for the ULN2003 was rather straight forward and only needed 4 wires connected to the esp32 and then power and ground for both the driver and esp32\nSoftware To test that everything was working I wrote a quick arduino program to spin the motor in both directions for a few seconds. After confirming my wiring was correct and the code ran I started to write the Esphome code. During this process, I discovered that RoadKillUK had published a Github that was very similar to what I was trying to accomplish. I only had to modify the code slightly to work with an esp32 but it was pretty much perfect.\nUsage \u0026amp; Future Improvements I\u0026rsquo;ve been running the blind for a little over a year now and have had no issue with it so far. There are a few things that I would change if I made a second version. First, the blinds are slow, they take over a minuet to raise/lower about 3 feet. Second, the stepper motor loses its memory of the blind position if it loses power and will need to be re-homed.\n","permalink":"http://localhost:1313/posts/smart-blinds-v1/","summary":"Cheap, simple and effective smart blinds made from and old IKEA roller shades and a few electronic components.","title":"Smart Blinds"},{"content":"I’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\nMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003eI’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\u003c/p\u003e\n\u003cp\u003eMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\u003c/p\u003e","title":"About"},{"content":" Goop\nHardware ESP32-C3 Super Mini Force Sensitive Resistor (FSR) 10K ohm Resistor 3D-Printed Case As I often use ESP32-C3 Super Minis in a lot of my projects due to their extremely small size I had already designed a slim case for them which worked prefectly for this application. The case can be found here on my MakerWorld Profile Page.\nWiring Software Using Esphome I wrote a basic yaml code to publish a resistor value as well as a binary occupancy value to HomeAssistant that can be found here.\n","permalink":"http://localhost:1313/posts/duck-launcher/","summary":"How we made the highest scoring duck launcher.","title":"Duck Launcher"},{"content":" Hardware ESP32-C3 Super Mini Force Sensitive Resistor (FSR) 10K ohm Resistor 3D-Printed Case As I often use ESP32-C3 Super Minis in a lot of my projects due to their extremely small size I had already designed a slim case for them which worked prefectly for this application. The case can be found here on my MakerWorld Profile Page.\nWiring The wiring was very simple, I just soldered one pin of the FSR to 3.3v and then the other pin to a analog pin, in my case pin 4, with the resistor connecting pin 4 and ground.\nSoftware Using Esphome I wrote a basic yaml code to publish a resistor value as well as a binary occupancy value to HomeAssistant that can be found here.\n","permalink":"http://localhost:1313/posts/bed-occupancy-sensor/","summary":"Low cost bed occupancy sensor made with an esp32-c3 super mini and a $10 resistor.","title":"Bed Occupancy Sensor"},{"content":" I wanted an automated blind solution that wouldn\u0026rsquo;t rely on cloud services or expensive commercial products. By repurposing an IKEA roller shades and designing my own controller system, I was able to build a cheap local solution.\nHardware The smart blind consists of four main components:\n28BYJ-48 stepper motor ULN2003 stepper motor driver board ESP32 microcontroller IKEA roller shade I chose these because they were very cheap off of Amazon or Aliexpress and because the ULN2003 was supported by Esphome\u0026rsquo;s stepper component which I was planning on using to program the esp32.\n3D-Printed Case To mount and house the motor and eletronics I designed a 3d printed case in Fusion360. This was my first time cading gears so it took me a bit to get the correct gear ration that would allow the motor to have enough torque to raise the blinds without skipping. After that it was just a matter of blocking out where each component would go and build the case around them.\nWiring The wiring for the ULN2003 was rather straight forward and only needed 4 wires connected to the esp32 and then power and ground for both the driver and esp32\nSoftware To test that everything was working I wrote a quick arduino program to spin the motor in both directions for a few seconds. After confirming my wiring was correct and the code ran I started to write the Esphome code. During this process, I discovered that RoadKillUK had published a Github that was very similar to what I was trying to accomplish. I only had to modify the code slightly to work with an esp32 but it was pretty much perfect.\nUsage \u0026amp; Future Improvements I\u0026rsquo;ve been running the blind for a little over a year now and have had no issue with it so far. There are a few things that I would change if I made a second version. First, the blinds are slow, they take over a minuet to raise/lower about 3 feet. Second, the stepper motor loses its memory of the blind position if it loses power and will need to be re-homed.\n","permalink":"http://localhost:1313/posts/smart-blinds-v1/","summary":"Cheap, simple and effective smart blinds made from and old IKEA roller shades and a few electronic components.","title":"Smart Blinds"},{"content":"I’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\nMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003eI’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\u003c/p\u003e\n\u003cp\u003eMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\u003c/p\u003e","title":"About"},{"content":" Goop\nHardware ESP32-C3 Super Mini Force Sensitive Resistor (FSR) 10K ohm Resistor 3D-Printed Case As I often use ESP32-C3 Super Minis in a lot of my projects due to their extremely small size I had already designed a slim case for them which worked prefectly for this application. The case can be found here on my MakerWorld Profile Page.\nWiring Software Using Esphome I wrote a basic yaml code to publish a resistor value as well as a binary occupancy value to HomeAssistant that can be found here.\n","permalink":"http://localhost:1313/posts/duck-launcher/","summary":"How we made the highest scoring duck launcher.","title":"Duck Launcher"},{"content":" Hardware ESP32-C3 Super Mini Force Sensitive Resistor (FSR) 10K ohm Resistor 3D-Printed Case As I often use ESP32-C3 Super Minis in a lot of my projects due to their extremely small size I had already designed a slim case for them which worked prefectly for this application. The case can be found here on my MakerWorld Profile Page.\nWiring The wiring was very simple, I just soldered one pin of the FSR to 3.3v and then the other pin to a analog pin, in my case pin 4, with the resistor connecting pin 4 and ground.\nSoftware Using Esphome I wrote a basic yaml code to publish a resistor value as well as a binary occupancy value to HomeAssistant that can be found here.\n","permalink":"http://localhost:1313/posts/bed-occupancy-sensor/","summary":"Low cost bed occupancy sensor made with an esp32-c3 super mini and a $10 resistor.","title":"Bed Occupancy Sensor"},{"content":" I wanted an automated blind solution that wouldn\u0026rsquo;t rely on cloud services or expensive commercial products. By repurposing an IKEA roller shades and designing my own controller system, I was able to build a cheap local solution.\nHardware The smart blind consists of four main components:\n28BYJ-48 stepper motor ULN2003 stepper motor driver board ESP32 microcontroller IKEA roller shade I chose these because they were very cheap off of Amazon or Aliexpress and because the ULN2003 was supported by Esphome\u0026rsquo;s stepper component which I was planning on using to program the esp32.\n3D-Printed Case To mount and house the motor and eletronics I designed a 3d printed case in Fusion360. This was my first time cading gears so it took me a bit to get the correct gear ration that would allow the motor to have enough torque to raise the blinds without skipping. After that it was just a matter of blocking out where each component would go and build the case around them.\nWiring The wiring for the ULN2003 was rather straight forward and only needed 4 wires connected to the esp32 and then power and ground for both the driver and esp32\nSoftware To test that everything was working I wrote a quick arduino program to spin the motor in both directions for a few seconds. After confirming my wiring was correct and the code ran I started to write the Esphome code. During this process, I discovered that RoadKillUK had published a Github that was very similar to what I was trying to accomplish. I only had to modify the code slightly to work with an esp32 but it was pretty much perfect.\nUsage \u0026amp; Future Improvements I\u0026rsquo;ve been running the blind for a little over a year now and have had no issue with it so far. There are a few things that I would change if I made a second version. First, the blinds are slow, they take over a minuet to raise/lower about 3 feet. Second, the stepper motor loses its memory of the blind position if it loses power and will need to be re-homed.\n","permalink":"http://localhost:1313/posts/smart-blinds-v1/","summary":"Cheap, simple and effective smart blinds made from and old IKEA roller shades and a few electronic components.","title":"Smart Blinds"},{"content":"I’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\nMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003eI’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\u003c/p\u003e\n\u003cp\u003eMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\u003c/p\u003e","title":"About"},{"content":" Goop\nHardware ESP32-C3 Super Mini Force Sensitive Resistor (FSR) 10K ohm Resistor 3D-Printed Case As I often use ESP32-C3 Super Minis in a lot of my projects due to their extremely small size I had already designed a slim case for them which worked prefectly for this application. The case can be found here on my MakerWorld Profile Page.\nWiring Software Using Esphome I wrote a basic yaml code to publish a resistor value as well as a binary occupancy value to HomeAssistant that can be found here.\n","permalink":"http://localhost:1313/posts/duck-launcher/","summary":"How we made the highest scoring duck launcher.","title":"Duck Launcher"},{"content":" Hardware ESP32-C3 Super Mini Force Sensitive Resistor (FSR) 10K ohm Resistor 3D-Printed Case As I often use ESP32-C3 Super Minis in a lot of my projects due to their extremely small size I had already designed a slim case for them which worked prefectly for this application. The case can be found here on my MakerWorld Profile Page.\nWiring The wiring was very simple, I just soldered one pin of the FSR to 3.3v and then the other pin to a analog pin, in my case pin 4, with the resistor connecting pin 4 and ground.\nSoftware Using Esphome I wrote a basic yaml code to publish a resistor value as well as a binary occupancy value to HomeAssistant that can be found here.\n","permalink":"http://localhost:1313/posts/bed-occupancy-sensor/","summary":"Low cost bed occupancy sensor made with an esp32-c3 super mini and a $10 resistor.","title":"Bed Occupancy Sensor"},{"content":" I wanted an automated blind solution that wouldn\u0026rsquo;t rely on cloud services or expensive commercial products. By repurposing an IKEA roller shades and designing my own controller system, I was able to build a cheap local solution.\nHardware The smart blind consists of four main components:\n28BYJ-48 stepper motor ULN2003 stepper motor driver board ESP32 microcontroller IKEA roller shade I chose these because they were very cheap off of Amazon or Aliexpress and because the ULN2003 was supported by Esphome\u0026rsquo;s stepper component which I was planning on using to program the esp32.\n3D-Printed Case To mount and house the motor and eletronics I designed a 3d printed case in Fusion360. This was my first time cading gears so it took me a bit to get the correct gear ration that would allow the motor to have enough torque to raise the blinds without skipping. After that it was just a matter of blocking out where each component would go and build the case around them.\nWiring The wiring for the ULN2003 was rather straight forward and only needed 4 wires connected to the esp32 and then power and ground for both the driver and esp32\nSoftware To test that everything was working I wrote a quick arduino program to spin the motor in both directions for a few seconds. After confirming my wiring was correct and the code ran I started to write the Esphome code. During this process, I discovered that RoadKillUK had published a Github that was very similar to what I was trying to accomplish. I only had to modify the code slightly to work with an esp32 but it was pretty much perfect.\nUsage \u0026amp; Future Improvements I\u0026rsquo;ve been running the blind for a little over a year now and have had no issue with it so far. There are a few things that I would change if I made a second version. First, the blinds are slow, they take over a minuet to raise/lower about 3 feet. Second, the stepper motor loses its memory of the blind position if it loses power and will need to be re-homed.\n","permalink":"http://localhost:1313/posts/smart-blinds-v1/","summary":"Cheap, simple and effective smart blinds made from and old IKEA roller shades and a few electronic components.","title":"Smart Blinds"},{"content":"I’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\nMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003eI’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\u003c/p\u003e\n\u003cp\u003eMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\u003c/p\u003e","title":"About"},{"content":" Goop\nHardware ESP32-C3 Super Mini Force Sensitive Resistor (FSR) 10K ohm Resistor 3D-Printed Case As I often use ESP32-C3 Super Minis in a lot of my projects due to their extremely small size I had already designed a slim case for them which worked prefectly for this application. The case can be found here on my MakerWorld Profile Page.\nWiring Software Using Esphome I wrote a basic yaml code to publish a resistor value as well as a binary occupancy value to HomeAssistant that can be found here.\nVideo of our Final run ","permalink":"http://localhost:1313/posts/duck-launcher/","summary":"How we made the highest scoring duck launcher.","title":"Duck Launcher"},{"content":" Hardware ESP32-C3 Super Mini Force Sensitive Resistor (FSR) 10K ohm Resistor 3D-Printed Case As I often use ESP32-C3 Super Minis in a lot of my projects due to their extremely small size I had already designed a slim case for them which worked prefectly for this application. The case can be found here on my MakerWorld Profile Page.\nWiring The wiring was very simple, I just soldered one pin of the FSR to 3.3v and then the other pin to a analog pin, in my case pin 4, with the resistor connecting pin 4 and ground.\nSoftware Using Esphome I wrote a basic yaml code to publish a resistor value as well as a binary occupancy value to HomeAssistant that can be found here.\n","permalink":"http://localhost:1313/posts/bed-occupancy-sensor/","summary":"Low cost bed occupancy sensor made with an esp32-c3 super mini and a $10 resistor.","title":"Bed Occupancy Sensor"},{"content":" I wanted an automated blind solution that wouldn\u0026rsquo;t rely on cloud services or expensive commercial products. By repurposing an IKEA roller shades and designing my own controller system, I was able to build a cheap local solution.\nHardware The smart blind consists of four main components:\n28BYJ-48 stepper motor ULN2003 stepper motor driver board ESP32 microcontroller IKEA roller shade I chose these because they were very cheap off of Amazon or Aliexpress and because the ULN2003 was supported by Esphome\u0026rsquo;s stepper component which I was planning on using to program the esp32.\n3D-Printed Case To mount and house the motor and eletronics I designed a 3d printed case in Fusion360. This was my first time cading gears so it took me a bit to get the correct gear ration that would allow the motor to have enough torque to raise the blinds without skipping. After that it was just a matter of blocking out where each component would go and build the case around them.\nWiring The wiring for the ULN2003 was rather straight forward and only needed 4 wires connected to the esp32 and then power and ground for both the driver and esp32\nSoftware To test that everything was working I wrote a quick arduino program to spin the motor in both directions for a few seconds. After confirming my wiring was correct and the code ran I started to write the Esphome code. During this process, I discovered that RoadKillUK had published a Github that was very similar to what I was trying to accomplish. I only had to modify the code slightly to work with an esp32 but it was pretty much perfect.\nUsage \u0026amp; Future Improvements I\u0026rsquo;ve been running the blind for a little over a year now and have had no issue with it so far. There are a few things that I would change if I made a second version. First, the blinds are slow, they take over a minuet to raise/lower about 3 feet. Second, the stepper motor loses its memory of the blind position if it loses power and will need to be re-homed.\n","permalink":"http://localhost:1313/posts/smart-blinds-v1/","summary":"Cheap, simple and effective smart blinds made from and old IKEA roller shades and a few electronic components.","title":"Smart Blinds"},{"content":"I’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\nMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003eI’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\u003c/p\u003e\n\u003cp\u003eMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\u003c/p\u003e","title":"About"},{"content":" Duck Launcher Final At UCF every freshman engineering student is tasked with designing and programming a TI-RSLK robot to score as many little rubber ducks in the \u0026ldquo;pond\u0026rdquo; as fast as possible. The pond is a large pentagon in the middle of 5 tracks that teams are trying to score into. There are 3 zones in pond, each getting progressively smaller and worth more points; 100, 300, and 500 respectively.\nESP32-C3 Super Mini Force Sensitive Resistor (FSR) 10K ohm Resistor 3D-Printed Case As I often use ESP32-C3 Super Minis in a lot of my projects due to their extremely small size I had already designed a slim case for them which worked prefectly for this application. The case can be found here on my MakerWorld Profile Page.\nWiring Software Using Esphome I wrote a basic yaml code to publish a resistor value as well as a binary occupancy value to HomeAssistant that can be found here.\nVideo of our Final run ","permalink":"http://localhost:1313/posts/duck-launcher/","summary":"How we made the highest scoring duck launcher.","title":"Duck Launcher"},{"content":" Hardware ESP32-C3 Super Mini Force Sensitive Resistor (FSR) 10K ohm Resistor 3D-Printed Case As I often use ESP32-C3 Super Minis in a lot of my projects due to their extremely small size I had already designed a slim case for them which worked prefectly for this application. The case can be found here on my MakerWorld Profile Page.\nWiring The wiring was very simple, I just soldered one pin of the FSR to 3.3v and then the other pin to a analog pin, in my case pin 4, with the resistor connecting pin 4 and ground.\nSoftware Using Esphome I wrote a basic yaml code to publish a resistor value as well as a binary occupancy value to HomeAssistant that can be found here.\n","permalink":"http://localhost:1313/posts/bed-occupancy-sensor/","summary":"Low cost bed occupancy sensor made with an esp32-c3 super mini and a $10 resistor.","title":"Bed Occupancy Sensor"},{"content":" I wanted an automated blind solution that wouldn\u0026rsquo;t rely on cloud services or expensive commercial products. By repurposing an IKEA roller shades and designing my own controller system, I was able to build a cheap local solution.\nHardware The smart blind consists of four main components:\n28BYJ-48 stepper motor ULN2003 stepper motor driver board ESP32 microcontroller IKEA roller shade I chose these because they were very cheap off of Amazon or Aliexpress and because the ULN2003 was supported by Esphome\u0026rsquo;s stepper component which I was planning on using to program the esp32.\n3D-Printed Case To mount and house the motor and eletronics I designed a 3d printed case in Fusion360. This was my first time cading gears so it took me a bit to get the correct gear ration that would allow the motor to have enough torque to raise the blinds without skipping. After that it was just a matter of blocking out where each component would go and build the case around them.\nWiring The wiring for the ULN2003 was rather straight forward and only needed 4 wires connected to the esp32 and then power and ground for both the driver and esp32\nSoftware To test that everything was working I wrote a quick arduino program to spin the motor in both directions for a few seconds. After confirming my wiring was correct and the code ran I started to write the Esphome code. During this process, I discovered that RoadKillUK had published a Github that was very similar to what I was trying to accomplish. I only had to modify the code slightly to work with an esp32 but it was pretty much perfect.\nUsage \u0026amp; Future Improvements I\u0026rsquo;ve been running the blind for a little over a year now and have had no issue with it so far. There are a few things that I would change if I made a second version. First, the blinds are slow, they take over a minuet to raise/lower about 3 feet. Second, the stepper motor loses its memory of the blind position if it loses power and will need to be re-homed.\n","permalink":"http://localhost:1313/posts/smart-blinds-v1/","summary":"Cheap, simple and effective smart blinds made from and old IKEA roller shades and a few electronic components.","title":"Smart Blinds"},{"content":"I’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\nMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003eI’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\u003c/p\u003e\n\u003cp\u003eMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\u003c/p\u003e","title":"About"},{"content":" Duck Launcher Final At UCF every freshman engineering student is tasked with designing and programming a TI-RSLK robot to score as many little rubber ducks in the \u0026ldquo;pond\u0026rdquo; as fast as possible. The pond is a large pentagon in the middle of 5 tracks that teams are trying to score into. There are 3 zones in pond, each getting progressively smaller and worth more points; 100, 300, and 500 respectively.\nESP32-C3 Super Mini Force Sensitive Resistor (FSR) 10K ohm Resistor 3D-Printed Case As I often use ESP32-C3 Super Minis in a lot of my projects due to their extremely small size I had already designed a slim case for them which worked prefectly for this application. The case can be found here on my MakerWorld Profile Page.\nWiring Software Using Esphome I wrote a basic yaml code to publish a resistor value as well as a binary occupancy value to HomeAssistant that can be found here.\nVideo of our Final run ","permalink":"http://localhost:1313/posts/duck-launcher/","summary":"How we made the highest scoring duck launcher.","title":"Duck Launcher"},{"content":" Hardware ESP32-C3 Super Mini Force Sensitive Resistor (FSR) 10K ohm Resistor 3D-Printed Case As I often use ESP32-C3 Super Minis in a lot of my projects due to their extremely small size I had already designed a slim case for them which worked prefectly for this application. The case can be found here on my MakerWorld Profile Page.\nWiring The wiring was very simple, I just soldered one pin of the FSR to 3.3v and then the other pin to a analog pin, in my case pin 4, with the resistor connecting pin 4 and ground.\nSoftware Using Esphome I wrote a basic yaml code to publish a resistor value as well as a binary occupancy value to HomeAssistant that can be found here.\n","permalink":"http://localhost:1313/posts/bed-occupancy-sensor/","summary":"Low cost bed occupancy sensor made with an esp32-c3 super mini and a $10 resistor.","title":"Bed Occupancy Sensor"},{"content":" I wanted an automated blind solution that wouldn\u0026rsquo;t rely on cloud services or expensive commercial products. By repurposing an IKEA roller shades and designing my own controller system, I was able to build a cheap local solution.\nHardware The smart blind consists of four main components:\n28BYJ-48 stepper motor ULN2003 stepper motor driver board ESP32 microcontroller IKEA roller shade I chose these because they were very cheap off of Amazon or Aliexpress and because the ULN2003 was supported by Esphome\u0026rsquo;s stepper component which I was planning on using to program the esp32.\n3D-Printed Case To mount and house the motor and eletronics I designed a 3d printed case in Fusion360. This was my first time cading gears so it took me a bit to get the correct gear ration that would allow the motor to have enough torque to raise the blinds without skipping. After that it was just a matter of blocking out where each component would go and build the case around them.\nWiring The wiring for the ULN2003 was rather straight forward and only needed 4 wires connected to the esp32 and then power and ground for both the driver and esp32\nSoftware To test that everything was working I wrote a quick arduino program to spin the motor in both directions for a few seconds. After confirming my wiring was correct and the code ran I started to write the Esphome code. During this process, I discovered that RoadKillUK had published a Github that was very similar to what I was trying to accomplish. I only had to modify the code slightly to work with an esp32 but it was pretty much perfect.\nUsage \u0026amp; Future Improvements I\u0026rsquo;ve been running the blind for a little over a year now and have had no issue with it so far. There are a few things that I would change if I made a second version. First, the blinds are slow, they take over a minuet to raise/lower about 3 feet. Second, the stepper motor loses its memory of the blind position if it loses power and will need to be re-homed.\n","permalink":"http://localhost:1313/posts/smart-blinds-v1/","summary":"Cheap, simple and effective smart blinds made from and old IKEA roller shades and a few electronic components.","title":"Smart Blinds"},{"content":"I’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\nMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003eI’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\u003c/p\u003e\n\u003cp\u003eMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\u003c/p\u003e","title":"About"},{"content":" Duck Launcher Final At UCF every freshman engineering student are split into groups of four and are tasked with designing and programming a TI-RSLK robot to score as many little rubber ducks in the \u0026ldquo;pond\u0026rdquo; as fast as possible by following a black line to the pond. The pond is a large pentagon in the middle of 5 tracks that teams are trying to score into. There are 3 zones in pond, each getting progressively smaller and worth more points; 100, 300, and 500 respectively. There are also penalty cups, the cups closest to the black line and are a time penalty if hit, and bonus cups which are at the start line and can be hit on the way back for a 50 point bonus every time.\nDesign Our main design goal was to score in the 500 point section as quickly as possible. We really want to get cycle times to be as quick as possible as we were worried about the small size of the center 500 point ring filling up and preventing us from scoring all the points possible. After testing out several design archetypes we\nVideo of our Final run ","permalink":"http://localhost:1313/posts/duck-launcher/","summary":"How we made the highest scoring duck launcher.","title":"Duck Launcher"},{"content":" Hardware ESP32-C3 Super Mini Force Sensitive Resistor (FSR) 10K ohm Resistor 3D-Printed Case As I often use ESP32-C3 Super Minis in a lot of my projects due to their extremely small size I had already designed a slim case for them which worked prefectly for this application. The case can be found here on my MakerWorld Profile Page.\nWiring The wiring was very simple, I just soldered one pin of the FSR to 3.3v and then the other pin to a analog pin, in my case pin 4, with the resistor connecting pin 4 and ground.\nSoftware Using Esphome I wrote a basic yaml code to publish a resistor value as well as a binary occupancy value to HomeAssistant that can be found here.\n","permalink":"http://localhost:1313/posts/bed-occupancy-sensor/","summary":"Low cost bed occupancy sensor made with an esp32-c3 super mini and a $10 resistor.","title":"Bed Occupancy Sensor"},{"content":" I wanted an automated blind solution that wouldn\u0026rsquo;t rely on cloud services or expensive commercial products. By repurposing an IKEA roller shades and designing my own controller system, I was able to build a cheap local solution.\nHardware The smart blind consists of four main components:\n28BYJ-48 stepper motor ULN2003 stepper motor driver board ESP32 microcontroller IKEA roller shade I chose these because they were very cheap off of Amazon or Aliexpress and because the ULN2003 was supported by Esphome\u0026rsquo;s stepper component which I was planning on using to program the esp32.\n3D-Printed Case To mount and house the motor and eletronics I designed a 3d printed case in Fusion360. This was my first time cading gears so it took me a bit to get the correct gear ration that would allow the motor to have enough torque to raise the blinds without skipping. After that it was just a matter of blocking out where each component would go and build the case around them.\nWiring The wiring for the ULN2003 was rather straight forward and only needed 4 wires connected to the esp32 and then power and ground for both the driver and esp32\nSoftware To test that everything was working I wrote a quick arduino program to spin the motor in both directions for a few seconds. After confirming my wiring was correct and the code ran I started to write the Esphome code. During this process, I discovered that RoadKillUK had published a Github that was very similar to what I was trying to accomplish. I only had to modify the code slightly to work with an esp32 but it was pretty much perfect.\nUsage \u0026amp; Future Improvements I\u0026rsquo;ve been running the blind for a little over a year now and have had no issue with it so far. There are a few things that I would change if I made a second version. First, the blinds are slow, they take over a minuet to raise/lower about 3 feet. Second, the stepper motor loses its memory of the blind position if it loses power and will need to be re-homed.\n","permalink":"http://localhost:1313/posts/smart-blinds-v1/","summary":"Cheap, simple and effective smart blinds made from and old IKEA roller shades and a few electronic components.","title":"Smart Blinds"},{"content":"I’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\nMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003eI’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\u003c/p\u003e\n\u003cp\u003eMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\u003c/p\u003e","title":"About"},{"content":" Duck Launcher Final At UCF every freshman engineering student are split into groups of four and are tasked with designing and programming a TI-RSLK robot to score as many little rubber ducks in the \u0026ldquo;pond\u0026rdquo; as fast as possible by following a black line to the pond. The pond is a large pentagon in the middle of 5 tracks that teams are trying to score into. There are 3 zones in pond, each getting progressively smaller and worth more points; 100, 300, and 500 respectively. There are also penalty cups, the cups closest to the black line and are a time penalty if hit, and bonus cups which are at the start line and can be hit on the way back for a 50 point bonus every time.\nDesign Our main design goal was to score in the 500 point section as quickly as possible. We really want to get cycle times to be as quick as possible as we were worried about the small size of the center 500 point ring filling up and preventing us from scoring all the points possible. After testing out several design archetypes we\nVideo of our Final run ","permalink":"http://localhost:1313/posts/duck-launcher/","summary":"How we made the highest scoring duck launcher.","title":"Duck Launcher"},{"content":" Hardware ESP32-C3 Super Mini Force Sensitive Resistor (FSR) 10K ohm Resistor 3D-Printed Case As I often use ESP32-C3 Super Minis in a lot of my projects due to their extremely small size I had already designed a slim case for them which worked prefectly for this application. The case can be found here on my MakerWorld Profile Page.\nWiring The wiring was very simple, I just soldered one pin of the FSR to 3.3v and then the other pin to a analog pin, in my case pin 4, with the resistor connecting pin 4 and ground.\nSoftware Using Esphome I wrote a basic yaml code to publish a resistor value as well as a binary occupancy value to HomeAssistant that can be found here.\n","permalink":"http://localhost:1313/posts/bed-occupancy-sensor/","summary":"Low cost bed occupancy sensor made with an esp32-c3 super mini and a $10 resistor.","title":"Bed Occupancy Sensor"},{"content":" I wanted an automated blind solution that wouldn\u0026rsquo;t rely on cloud services or expensive commercial products. By repurposing an IKEA roller shades and designing my own controller system, I was able to build a cheap local solution.\nHardware The smart blind consists of four main components:\n28BYJ-48 stepper motor ULN2003 stepper motor driver board ESP32 microcontroller IKEA roller shade I chose these because they were very cheap off of Amazon or Aliexpress and because the ULN2003 was supported by Esphome\u0026rsquo;s stepper component which I was planning on using to program the esp32.\n3D-Printed Case To mount and house the motor and eletronics I designed a 3d printed case in Fusion360. This was my first time cading gears so it took me a bit to get the correct gear ration that would allow the motor to have enough torque to raise the blinds without skipping. After that it was just a matter of blocking out where each component would go and build the case around them.\nWiring The wiring for the ULN2003 was rather straight forward and only needed 4 wires connected to the esp32 and then power and ground for both the driver and esp32\nSoftware To test that everything was working I wrote a quick arduino program to spin the motor in both directions for a few seconds. After confirming my wiring was correct and the code ran I started to write the Esphome code. During this process, I discovered that RoadKillUK had published a Github that was very similar to what I was trying to accomplish. I only had to modify the code slightly to work with an esp32 but it was pretty much perfect.\nUsage \u0026amp; Future Improvements I\u0026rsquo;ve been running the blind for a little over a year now and have had no issue with it so far. There are a few things that I would change if I made a second version. First, the blinds are slow, they take over a minuet to raise/lower about 3 feet. Second, the stepper motor loses its memory of the blind position if it loses power and will need to be re-homed.\n","permalink":"http://localhost:1313/posts/smart-blinds-v1/","summary":"Cheap, simple and effective smart blinds made from and old IKEA roller shades and a few electronic components.","title":"Smart Blinds"},{"content":"I’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\nMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003eI’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\u003c/p\u003e\n\u003cp\u003eMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\u003c/p\u003e","title":"About"},{"content":" Duck Launcher Final At UCF every freshman engineering student are split into groups of four and are tasked with designing and programming a TI-RSLK robot to score as many little rubber ducks in the \u0026ldquo;pond\u0026rdquo; as fast as possible by following a black line to the pond.\nThe pond is a large pentagon in the middle of 5 tracks that teams are trying to score into. There are 3 zones in pond, each getting progressively smaller and worth more points; 100, 300, and 500 respectively. There are also penalty cups, the cups closest to the black line and are a time penalty if hit, and bonus cups which are at the start line and can be hit on the way back for a 50 point bonus every time.\nDesign Our main design goal was to score in the 500 point section as quickly as possible. We really want to get cycle times to be as quick as possible as we were worried about the small size of the center 500 point ring filling up and preventing us from scoring all the points possible. After testing out several design archetypes we\nVideo of our Final run ","permalink":"http://localhost:1313/posts/duck-launcher/","summary":"How we made the highest scoring duck launcher.","title":"Duck Launcher"},{"content":" Hardware ESP32-C3 Super Mini Force Sensitive Resistor (FSR) 10K ohm Resistor 3D-Printed Case As I often use ESP32-C3 Super Minis in a lot of my projects due to their extremely small size I had already designed a slim case for them which worked prefectly for this application. The case can be found here on my MakerWorld Profile Page.\nWiring The wiring was very simple, I just soldered one pin of the FSR to 3.3v and then the other pin to a analog pin, in my case pin 4, with the resistor connecting pin 4 and ground.\nSoftware Using Esphome I wrote a basic yaml code to publish a resistor value as well as a binary occupancy value to HomeAssistant that can be found here.\n","permalink":"http://localhost:1313/posts/bed-occupancy-sensor/","summary":"Low cost bed occupancy sensor made with an esp32-c3 super mini and a $10 resistor.","title":"Bed Occupancy Sensor"},{"content":" I wanted an automated blind solution that wouldn\u0026rsquo;t rely on cloud services or expensive commercial products. By repurposing an IKEA roller shades and designing my own controller system, I was able to build a cheap local solution.\nHardware The smart blind consists of four main components:\n28BYJ-48 stepper motor ULN2003 stepper motor driver board ESP32 microcontroller IKEA roller shade I chose these because they were very cheap off of Amazon or Aliexpress and because the ULN2003 was supported by Esphome\u0026rsquo;s stepper component which I was planning on using to program the esp32.\n3D-Printed Case To mount and house the motor and eletronics I designed a 3d printed case in Fusion360. This was my first time cading gears so it took me a bit to get the correct gear ration that would allow the motor to have enough torque to raise the blinds without skipping. After that it was just a matter of blocking out where each component would go and build the case around them.\nWiring The wiring for the ULN2003 was rather straight forward and only needed 4 wires connected to the esp32 and then power and ground for both the driver and esp32\nSoftware To test that everything was working I wrote a quick arduino program to spin the motor in both directions for a few seconds. After confirming my wiring was correct and the code ran I started to write the Esphome code. During this process, I discovered that RoadKillUK had published a Github that was very similar to what I was trying to accomplish. I only had to modify the code slightly to work with an esp32 but it was pretty much perfect.\nUsage \u0026amp; Future Improvements I\u0026rsquo;ve been running the blind for a little over a year now and have had no issue with it so far. There are a few things that I would change if I made a second version. First, the blinds are slow, they take over a minuet to raise/lower about 3 feet. Second, the stepper motor loses its memory of the blind position if it loses power and will need to be re-homed.\n","permalink":"http://localhost:1313/posts/smart-blinds-v1/","summary":"Cheap, simple and effective smart blinds made from and old IKEA roller shades and a few electronic components.","title":"Smart Blinds"},{"content":"I’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\nMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003eI’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\u003c/p\u003e\n\u003cp\u003eMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\u003c/p\u003e","title":"About"},{"content":" Duck Launcher Final At UCF every freshman engineering student are split into groups of four and are tasked with designing and programming a TI-RSLK robot to score as many little rubber ducks in the \u0026ldquo;pond\u0026rdquo; as fast as possible by following a black line to the pond.\nThe pond is a large pentagon in the middle of 5 tracks that teams are trying to score into. There are 3 zones in pond, each getting progressively smaller and worth more points; 100, 300, and 500 respectively. There are also penalty cups, the cups closest to the black line and are a time penalty if hit, and bonus cups which are at the start line and can be hit on the way back for a 50 point bonus every time.\nDesign Our main design goal was to score in the 500 point section as quickly as possible. We really want to get cycle times to be as quick as possible as we were worried about the small size of the center 500 point ring filling up and preventing us from scoring all the points possible. Some restraints we had to follow were that the robot must be against the pond wall before shooting a duck and the motors on the robot were rather weak making it essential we keep the weight of our mechanisms to a minimum.\nAfter testing out several design archetypes we settled on a motorized shooter. This would allow us to quickly shoot ducks as soon as hitting the wall of the pond and it would be overall a very lightweight and compact mechanism. Here is the link to the cad for anyone interest: CAD Model - Onshape\nVideo of our Final run ","permalink":"http://localhost:1313/posts/duck-launcher/","summary":"How we made the highest scoring duck launcher.","title":"Duck Launcher"},{"content":" Hardware ESP32-C3 Super Mini Force Sensitive Resistor (FSR) 10K ohm Resistor 3D-Printed Case As I often use ESP32-C3 Super Minis in a lot of my projects due to their extremely small size I had already designed a slim case for them which worked prefectly for this application. The case can be found here on my MakerWorld Profile Page.\nWiring The wiring was very simple, I just soldered one pin of the FSR to 3.3v and then the other pin to a analog pin, in my case pin 4, with the resistor connecting pin 4 and ground.\nSoftware Using Esphome I wrote a basic yaml code to publish a resistor value as well as a binary occupancy value to HomeAssistant that can be found here.\n","permalink":"http://localhost:1313/posts/bed-occupancy-sensor/","summary":"Low cost bed occupancy sensor made with an esp32-c3 super mini and a $10 resistor.","title":"Bed Occupancy Sensor"},{"content":" I wanted an automated blind solution that wouldn\u0026rsquo;t rely on cloud services or expensive commercial products. By repurposing an IKEA roller shades and designing my own controller system, I was able to build a cheap local solution.\nHardware The smart blind consists of four main components:\n28BYJ-48 stepper motor ULN2003 stepper motor driver board ESP32 microcontroller IKEA roller shade I chose these because they were very cheap off of Amazon or Aliexpress and because the ULN2003 was supported by Esphome\u0026rsquo;s stepper component which I was planning on using to program the esp32.\n3D-Printed Case To mount and house the motor and eletronics I designed a 3d printed case in Fusion360. This was my first time cading gears so it took me a bit to get the correct gear ration that would allow the motor to have enough torque to raise the blinds without skipping. After that it was just a matter of blocking out where each component would go and build the case around them.\nWiring The wiring for the ULN2003 was rather straight forward and only needed 4 wires connected to the esp32 and then power and ground for both the driver and esp32\nSoftware To test that everything was working I wrote a quick arduino program to spin the motor in both directions for a few seconds. After confirming my wiring was correct and the code ran I started to write the Esphome code. During this process, I discovered that RoadKillUK had published a Github that was very similar to what I was trying to accomplish. I only had to modify the code slightly to work with an esp32 but it was pretty much perfect.\nUsage \u0026amp; Future Improvements I\u0026rsquo;ve been running the blind for a little over a year now and have had no issue with it so far. There are a few things that I would change if I made a second version. First, the blinds are slow, they take over a minuet to raise/lower about 3 feet. Second, the stepper motor loses its memory of the blind position if it loses power and will need to be re-homed.\n","permalink":"http://localhost:1313/posts/smart-blinds-v1/","summary":"Cheap, simple and effective smart blinds made from and old IKEA roller shades and a few electronic components.","title":"Smart Blinds"},{"content":"I’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\nMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003eI’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\u003c/p\u003e\n\u003cp\u003eMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\u003c/p\u003e","title":"About"},{"content":" Duck Launcher Final At UCF every freshman engineering student are split into groups of four and are tasked with designing and programming a TI-RSLK robot to score as many little rubber ducks in the \u0026ldquo;pond\u0026rdquo; as fast as possible by following a black line to the pond.\nThe pond is a large pentagon in the middle of 5 tracks that teams are trying to score into. There are 3 zones in pond, each getting progressively smaller and worth more points; 100, 300, and 500 respectively. There are also penalty cups, the cups closest to the black line and are a time penalty if hit, and bonus cups which are at the start line and can be hit on the way back for a 50 point bonus every time.\nDesign Our main design goal was to score in the 500 point section as quickly as possible. We really want to get cycle times to be as quick as possible as we were worried about the small size of the center 500 point ring filling up and preventing us from scoring all the points possible. Some restraints we had to follow were that the robot must be against the pond wall before shooting a duck and the motors on the robot were rather weak making it essential we keep the weight of our mechanisms to a minimum.\nAfter testing out several design archetypes we settled on a motorized lever arm. This would allow us to quickly shoot ducks as soon as hitting the wall of the pond and it would be overall a very lightweight and compact mechanism. We ended up going through seven versions of tweaking various gear rations and arm lengths before we finally settled on the model we used. Here is the link to the cad for anyone interest: CAD Model - Onshape\nProgramming Video of our Final run ","permalink":"http://localhost:1313/posts/duck-launcher/","summary":"How we made the highest scoring duck launcher.","title":"Duck Launcher"},{"content":" Hardware ESP32-C3 Super Mini Force Sensitive Resistor (FSR) 10K ohm Resistor 3D-Printed Case As I often use ESP32-C3 Super Minis in a lot of my projects due to their extremely small size I had already designed a slim case for them which worked prefectly for this application. The case can be found here on my MakerWorld Profile Page.\nWiring The wiring was very simple, I just soldered one pin of the FSR to 3.3v and then the other pin to a analog pin, in my case pin 4, with the resistor connecting pin 4 and ground.\nSoftware Using Esphome I wrote a basic yaml code to publish a resistor value as well as a binary occupancy value to HomeAssistant that can be found here.\n","permalink":"http://localhost:1313/posts/bed-occupancy-sensor/","summary":"Low cost bed occupancy sensor made with an esp32-c3 super mini and a $10 resistor.","title":"Bed Occupancy Sensor"},{"content":" I wanted an automated blind solution that wouldn\u0026rsquo;t rely on cloud services or expensive commercial products. By repurposing an IKEA roller shades and designing my own controller system, I was able to build a cheap local solution.\nHardware The smart blind consists of four main components:\n28BYJ-48 stepper motor ULN2003 stepper motor driver board ESP32 microcontroller IKEA roller shade I chose these because they were very cheap off of Amazon or Aliexpress and because the ULN2003 was supported by Esphome\u0026rsquo;s stepper component which I was planning on using to program the esp32.\n3D-Printed Case To mount and house the motor and eletronics I designed a 3d printed case in Fusion360. This was my first time cading gears so it took me a bit to get the correct gear ration that would allow the motor to have enough torque to raise the blinds without skipping. After that it was just a matter of blocking out where each component would go and build the case around them.\nWiring The wiring for the ULN2003 was rather straight forward and only needed 4 wires connected to the esp32 and then power and ground for both the driver and esp32\nSoftware To test that everything was working I wrote a quick arduino program to spin the motor in both directions for a few seconds. After confirming my wiring was correct and the code ran I started to write the Esphome code. During this process, I discovered that RoadKillUK had published a Github that was very similar to what I was trying to accomplish. I only had to modify the code slightly to work with an esp32 but it was pretty much perfect.\nUsage \u0026amp; Future Improvements I\u0026rsquo;ve been running the blind for a little over a year now and have had no issue with it so far. There are a few things that I would change if I made a second version. First, the blinds are slow, they take over a minuet to raise/lower about 3 feet. Second, the stepper motor loses its memory of the blind position if it loses power and will need to be re-homed.\n","permalink":"http://localhost:1313/posts/smart-blinds-v1/","summary":"Cheap, simple and effective smart blinds made from and old IKEA roller shades and a few electronic components.","title":"Smart Blinds"},{"content":"I’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\nMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003eI’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\u003c/p\u003e\n\u003cp\u003eMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\u003c/p\u003e","title":"About"},{"content":" Duck Launcher Final At UCF every freshman engineering student are split into groups of four and are tasked with designing and programming a TI-RSLK robot to score as many little rubber ducks in the \u0026ldquo;pond\u0026rdquo; as fast as possible by following a black line to the pond.\nThe pond is a large pentagon in the middle of 5 tracks that teams are trying to score into. There are 3 zones in pond, each getting progressively smaller and worth more points; 100, 300, and 500 respectively. There are also penalty cups, the cups closest to the black line and are a time penalty if hit, and bonus cups which are at the start line and can be hit on the way back for a 50 point bonus every time.\nDesign Our main design goal was to score in the 500 point section as quickly as possible. We really want to get cycle times to be as quick as possible as we were worried about the small size of the center 500 point ring filling up and preventing us from scoring all the points possible. Some restraints we had to follow were that the robot must be against the pond wall before shooting a duck and the motors on the robot were rather weak making it essential we keep the weight of our mechanisms to a minimum.\nAfter testing out several design archetypes we settled on a motorized lever arm. This would allow us to quickly shoot ducks as soon as hitting the wall of the pond and it would be overall a very lightweight and compact mechanism. We ended up going through seven versions of tweaking various gear rations and arm lengths before we finally settled on the model we used. Here is the link to the cad for anyone interest: CAD Model - Onshape\nProgramming Every group was provided with very basic but working example code. However, this code was very messy and extremely slow which caused me to decided to rewrite it from scratch. One of the biggest issues with the example code is that they do not use a full PID, instead they just use a P value. While this works fine for the majority of robots, if you wanted to go faster than about 30% speed a true PID iplimentation is required.\nVideo of our Final run ","permalink":"http://localhost:1313/posts/duck-launcher/","summary":"How we made the highest scoring duck launcher.","title":"Duck Launcher"},{"content":" Hardware ESP32-C3 Super Mini Force Sensitive Resistor (FSR) 10K ohm Resistor 3D-Printed Case As I often use ESP32-C3 Super Minis in a lot of my projects due to their extremely small size I had already designed a slim case for them which worked prefectly for this application. The case can be found here on my MakerWorld Profile Page.\nWiring The wiring was very simple, I just soldered one pin of the FSR to 3.3v and then the other pin to a analog pin, in my case pin 4, with the resistor connecting pin 4 and ground.\nSoftware Using Esphome I wrote a basic yaml code to publish a resistor value as well as a binary occupancy value to HomeAssistant that can be found here.\n","permalink":"http://localhost:1313/posts/bed-occupancy-sensor/","summary":"Low cost bed occupancy sensor made with an esp32-c3 super mini and a $10 resistor.","title":"Bed Occupancy Sensor"},{"content":" I wanted an automated blind solution that wouldn\u0026rsquo;t rely on cloud services or expensive commercial products. By repurposing an IKEA roller shades and designing my own controller system, I was able to build a cheap local solution.\nHardware The smart blind consists of four main components:\n28BYJ-48 stepper motor ULN2003 stepper motor driver board ESP32 microcontroller IKEA roller shade I chose these because they were very cheap off of Amazon or Aliexpress and because the ULN2003 was supported by Esphome\u0026rsquo;s stepper component which I was planning on using to program the esp32.\n3D-Printed Case To mount and house the motor and eletronics I designed a 3d printed case in Fusion360. This was my first time cading gears so it took me a bit to get the correct gear ration that would allow the motor to have enough torque to raise the blinds without skipping. After that it was just a matter of blocking out where each component would go and build the case around them.\nWiring The wiring for the ULN2003 was rather straight forward and only needed 4 wires connected to the esp32 and then power and ground for both the driver and esp32\nSoftware To test that everything was working I wrote a quick arduino program to spin the motor in both directions for a few seconds. After confirming my wiring was correct and the code ran I started to write the Esphome code. During this process, I discovered that RoadKillUK had published a Github that was very similar to what I was trying to accomplish. I only had to modify the code slightly to work with an esp32 but it was pretty much perfect.\nUsage \u0026amp; Future Improvements I\u0026rsquo;ve been running the blind for a little over a year now and have had no issue with it so far. There are a few things that I would change if I made a second version. First, the blinds are slow, they take over a minuet to raise/lower about 3 feet. Second, the stepper motor loses its memory of the blind position if it loses power and will need to be re-homed.\n","permalink":"http://localhost:1313/posts/smart-blinds-v1/","summary":"Cheap, simple and effective smart blinds made from and old IKEA roller shades and a few electronic components.","title":"Smart Blinds"},{"content":"I’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\nMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003eI’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\u003c/p\u003e\n\u003cp\u003eMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\u003c/p\u003e","title":"About"},{"content":" Duck Launcher Final At UCF every freshman engineering student are split into groups of four and are tasked with designing and programming a TI-RSLK robot to score as many little rubber ducks in the \u0026ldquo;pond\u0026rdquo; as fast as possible by following a black line to the pond.\nThe pond is a large pentagon in the middle of 5 tracks that teams are trying to score into. There are 3 zones in pond, each getting progressively smaller and worth more points; 100, 300, and 500 respectively. There are also penalty cups, the cups closest to the black line and are a time penalty if hit, and bonus cups which are at the start line and can be hit on the way back for a 50 point bonus every time.\nDesign Our main design goal was to score in the 500 point section as quickly as possible. We really want to get cycle times to be as quick as possible as we were worried about the small size of the center 500 point ring filling up and preventing us from scoring all the points possible. Some restraints we had to follow were that the robot must be against the pond wall before shooting a duck and the motors on the robot were rather weak making it essential we keep the weight of our mechanisms to a minimum.\nAfter testing out several design archetypes we settled on a motorized lever arm. This would allow us to quickly shoot ducks as soon as hitting the wall of the pond and it would be overall a very lightweight and compact mechanism. We ended up going through seven versions of tweaking various gear rations and arm lengths before we finally settled on the model we used. Here is the link to the cad for anyone interest: CAD Model - Onshape\nProgramming Every group was provided with very basic but working example code. However, this code was very messy and extremely slow which caused me to decide to rewrite it from scratch. One of the biggest issues with the example code is that they do not use a full PID, instead they just use a P value. While this works fine for the majority of robots, if you wanted to go faster than about 30% speed a true PID implementation is required.\nState Machine Architecture I structured the entire program around a state machine with six states: START, RESTART, PATH, SHOOT, TURN, and DONE. This made the code significantly cleaner and easier to debug compared to the tangled mess of if-else statements in the example code. Each state has its own dedicated function that handles exactly what needs to happen in that phase of the run.\nThe robot starts in START, waiting for a button press. Once triggered, it transitions to PATH where the line following happens. When the bump sensors detect the wall, it moves to SHOOT, fires the duck launcher mechanism, then enters TURN to do a 180-degree spin. After turning, it goes back to PATH to return home. On the second bump (hitting the bonus cups), it transitions to DONE and waits for a restart.\nFull PID Implementation The heart of the line following is a proper PID controller. We tuned our constants to KP = 0.05, KI = 0.001, and KD = 0.01 which allowed us to run at 90% motor speed while still tracking the line accurately. The key improvement over the example code was using actual time deltas for the integral and derivative calculations rather than assuming a fixed loop time.\nfloat dt = (currentTime - lastPIDTime) / 1000.0; // Convert to seconds int error = linePos - GOAL; float P = KP * error; integral += error * dt; integral = constrain(integral, -1000, 1000); // Anti-windup float I = KI * integral; float derivative = (error - lastError) / dt; float D = KD * derivative; float motor_speed_delta = P + I + D; The integral term includes anti-windup clamping to prevent it from accumulating too much error when the robot is off the line for extended periods. We also reset the PID state (error, integral, and timing) whenever transitioning between states to prevent any weird behavior from stale values.\nSensor Integration We used a BNO055 IMU for heading information, though in the final version we primarily relied on encoder-based turning. The 180-degree turn is calculated using encoder counts rather than the gyro, which turned out to be more reliable and consistent. The bump sensors on the front detect when we hit the pond wall, triggering the shooting sequence.\nThe line sensors required calibration values that we determined through testing. Each of the 8 sensors has its own min/max calibration range since they all have slightly different sensitivities. This calibration was critical for consistent line detection across different lighting conditions in the competition arena.\nShooter Control The shooting mechanism is dead simple - just a digital pin that triggers the motorized lever arm. A quick HIGH pulse for 300ms is all it takes to launch a duck into the pond. We added small delays before and after to ensure clean activation and to let the mechanism settle before moving again.\nVideo of our Final run ","permalink":"http://localhost:1313/posts/duck-launcher/","summary":"How we made the highest scoring duck launcher.","title":"Duck Launcher"},{"content":" Hardware ESP32-C3 Super Mini Force Sensitive Resistor (FSR) 10K ohm Resistor 3D-Printed Case As I often use ESP32-C3 Super Minis in a lot of my projects due to their extremely small size I had already designed a slim case for them which worked prefectly for this application. The case can be found here on my MakerWorld Profile Page.\nWiring The wiring was very simple, I just soldered one pin of the FSR to 3.3v and then the other pin to a analog pin, in my case pin 4, with the resistor connecting pin 4 and ground.\nSoftware Using Esphome I wrote a basic yaml code to publish a resistor value as well as a binary occupancy value to HomeAssistant that can be found here.\n","permalink":"http://localhost:1313/posts/bed-occupancy-sensor/","summary":"Low cost bed occupancy sensor made with an esp32-c3 super mini and a $10 resistor.","title":"Bed Occupancy Sensor"},{"content":" I wanted an automated blind solution that wouldn\u0026rsquo;t rely on cloud services or expensive commercial products. By repurposing an IKEA roller shades and designing my own controller system, I was able to build a cheap local solution.\nHardware The smart blind consists of four main components:\n28BYJ-48 stepper motor ULN2003 stepper motor driver board ESP32 microcontroller IKEA roller shade I chose these because they were very cheap off of Amazon or Aliexpress and because the ULN2003 was supported by Esphome\u0026rsquo;s stepper component which I was planning on using to program the esp32.\n3D-Printed Case To mount and house the motor and eletronics I designed a 3d printed case in Fusion360. This was my first time cading gears so it took me a bit to get the correct gear ration that would allow the motor to have enough torque to raise the blinds without skipping. After that it was just a matter of blocking out where each component would go and build the case around them.\nWiring The wiring for the ULN2003 was rather straight forward and only needed 4 wires connected to the esp32 and then power and ground for both the driver and esp32\nSoftware To test that everything was working I wrote a quick arduino program to spin the motor in both directions for a few seconds. After confirming my wiring was correct and the code ran I started to write the Esphome code. During this process, I discovered that RoadKillUK had published a Github that was very similar to what I was trying to accomplish. I only had to modify the code slightly to work with an esp32 but it was pretty much perfect.\nUsage \u0026amp; Future Improvements I\u0026rsquo;ve been running the blind for a little over a year now and have had no issue with it so far. There are a few things that I would change if I made a second version. First, the blinds are slow, they take over a minuet to raise/lower about 3 feet. Second, the stepper motor loses its memory of the blind position if it loses power and will need to be re-homed.\n","permalink":"http://localhost:1313/posts/smart-blinds-v1/","summary":"Cheap, simple and effective smart blinds made from and old IKEA roller shades and a few electronic components.","title":"Smart Blinds"},{"content":"I’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\nMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003eI’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\u003c/p\u003e\n\u003cp\u003eMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\u003c/p\u003e","title":"About"},{"content":" Duck Launcher Final At UCF every freshman engineering student are split into groups of four and are tasked with designing and programming a TI-RSLK robot to score as many little rubber ducks in the \u0026ldquo;pond\u0026rdquo; as fast as possible by following a black line to the pond.\nThe pond is a large pentagon in the middle of 5 tracks that teams are trying to score into. There are 3 zones in pond, each getting progressively smaller and worth more points; 100, 300, and 500 respectively. There are also penalty cups, the cups closest to the black line and are a time penalty if hit, and bonus cups which are at the start line and can be hit on the way back for a 50 point bonus every time.\nDesign Our main design goal was to score in the 500 point section as quickly as possible. We really want to get cycle times to be as quick as possible as we were worried about the small size of the center 500 point ring filling up and preventing us from scoring all the points possible. Some restraints we had to follow were that the robot must be against the pond wall before shooting a duck and the motors on the robot were rather weak making it essential we keep the weight of our mechanisms to a minimum.\nAfter testing out several design archetypes we settled on a motorized lever arm. This would allow us to quickly shoot ducks as soon as hitting the wall of the pond and it would be overall a very lightweight and compact mechanism. We ended up going through seven versions of tweaking various gear rations and arm lengths before we finally settled on the model we used. Here is the link to the cad for anyone interest: CAD Model - Onshape\nProgramming Every group was provided with very basic but working example code. However, this code was very messy and extremely slow which caused me to decide to rewrite it from scratch. One of the biggest issues with the example code is that they do not use a full PID, instead they just use a P value. While this works fine for the majority of robots, if you wanted to go faster than about 30% speed a true PID implementation is required.\nState Machine Architecture I structured the entire program around a state machine with six states: START, RESTART, PATH, SHOOT, TURN, and DONE. This made the code significantly cleaner and easier to debug compared to the tangled mess of if-else statements in the example code. Each state has its own dedicated function that handles exactly what needs to happen in that phase of the run.\nThe robot starts in START, waiting for a button press. Once triggered, it transitions to PATH where the line following happens. When the bump sensors detect the wall, it moves to SHOOT, fires the duck launcher mechanism, then enters TURN to do a 180-degree spin. After turning, it goes back to PATH to return home. On the second bump (hitting the bonus cups), it transitions to DONE and waits for a restart.\nFull PID Implementation The heart of the line following is a proper PID controller. We tuned our constants to KP = 0.05, KI = 0.001, and KD = 0.01 which allowed us to run at 90% motor speed while still tracking the line accurately. The key improvement over the example code was using actual time deltas for the integral and derivative calculations rather than assuming a fixed loop time.\nfloat dt = (currentTime - lastPIDTime) / 1000.0; // Convert to seconds int error = linePos - GOAL; float P = KP * error; integral += error * dt; integral = constrain(integral, -1000, 1000); // Anti-windup float I = KI * integral; float derivative = (error - lastError) / dt; float D = KD * derivative; float motor_speed_delta = P + I + D; The integral term includes anti-windup clamping to prevent it from accumulating too much error when the robot is off the line for extended periods. We also reset the PID state (error, integral, and timing) whenever transitioning between states to prevent any weird behavior from stale values.\nSensor Integration We used a BNO055 IMU for heading information, though in the final version we primarily relied on encoder-based turning. The 180-degree turn is calculated using encoder counts rather than the gyro, which turned out to be more reliable and consistent. The bump sensors on the front detect when we hit the pond wall, triggering the shooting sequence.\nThe line sensors required calibration values that we determined through testing. Each of the 8 sensors has its own min/max calibration range since they all have slightly different sensitivities. This calibration was critical for consistent line detection across different lighting conditions in the competition arena.\nShooter Control The shooting mechanism is dead simple - just a digital pin that triggers the motorized lever arm. A quick HIGH pulse for 300ms is all it takes to launch a duck into the pond. We added small delays before and after to ensure clean activation and to let the mechanism settle before moving again.\nVideo of our Final run ","permalink":"http://localhost:1313/posts/duck-launcher/","summary":"How we made the highest scoring duck launcher.","title":"Duck Launcher"},{"content":" Hardware ESP32-C3 Super Mini Force Sensitive Resistor (FSR) 10K ohm Resistor 3D-Printed Case As I often use ESP32-C3 Super Minis in a lot of my projects due to their extremely small size I had already designed a slim case for them which worked prefectly for this application. The case can be found here on my MakerWorld Profile Page.\nWiring The wiring was very simple, I just soldered one pin of the FSR to 3.3v and then the other pin to a analog pin, in my case pin 4, with the resistor connecting pin 4 and ground.\nSoftware Using Esphome I wrote a basic yaml code to publish a resistor value as well as a binary occupancy value to HomeAssistant that can be found here.\n","permalink":"http://localhost:1313/posts/bed-occupancy-sensor/","summary":"Low cost bed occupancy sensor made with an esp32-c3 super mini and a $10 resistor.","title":"Bed Occupancy Sensor"},{"content":" I wanted an automated blind solution that wouldn\u0026rsquo;t rely on cloud services or expensive commercial products. By repurposing an IKEA roller shades and designing my own controller system, I was able to build a cheap local solution.\nHardware The smart blind consists of four main components:\n28BYJ-48 stepper motor ULN2003 stepper motor driver board ESP32 microcontroller IKEA roller shade I chose these because they were very cheap off of Amazon or Aliexpress and because the ULN2003 was supported by Esphome\u0026rsquo;s stepper component which I was planning on using to program the esp32.\n3D-Printed Case To mount and house the motor and eletronics I designed a 3d printed case in Fusion360. This was my first time cading gears so it took me a bit to get the correct gear ration that would allow the motor to have enough torque to raise the blinds without skipping. After that it was just a matter of blocking out where each component would go and build the case around them.\nWiring The wiring for the ULN2003 was rather straight forward and only needed 4 wires connected to the esp32 and then power and ground for both the driver and esp32\nSoftware To test that everything was working I wrote a quick arduino program to spin the motor in both directions for a few seconds. After confirming my wiring was correct and the code ran I started to write the Esphome code. During this process, I discovered that RoadKillUK had published a Github that was very similar to what I was trying to accomplish. I only had to modify the code slightly to work with an esp32 but it was pretty much perfect.\nUsage \u0026amp; Future Improvements I\u0026rsquo;ve been running the blind for a little over a year now and have had no issue with it so far. There are a few things that I would change if I made a second version. First, the blinds are slow, they take over a minuet to raise/lower about 3 feet. Second, the stepper motor loses its memory of the blind position if it loses power and will need to be re-homed.\n","permalink":"http://localhost:1313/posts/smart-blinds-v1/","summary":"Cheap, simple and effective smart blinds made from and old IKEA roller shades and a few electronic components.","title":"Smart Blinds"},{"content":"I’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\nMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003eI’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\u003c/p\u003e\n\u003cp\u003eMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\u003c/p\u003e","title":"About"},{"content":" Duck Launcher Final At UCF every freshman engineering student are split into groups of four and are tasked with designing and programming a TI-RSLK robot to score as many little rubber ducks in the \u0026ldquo;pond\u0026rdquo; as fast as possible by following a black line to the pond.\nThe pond is a large pentagon in the middle of 5 tracks that teams are trying to score into. There are 3 zones in pond, each getting progressively smaller and worth more points; 100, 300, and 500 respectively. There are also penalty cups, the cups closest to the black line and are a time penalty if hit, and bonus cups which are at the start line and can be hit on the way back for a 50 point bonus every time.\nDesign Our main design goal was to score in the 500 point section as quickly as possible. We really want to get cycle times to be as quick as possible as we were worried about the small size of the center 500 point ring filling up and preventing us from scoring all the points possible. Some restraints we had to follow were that the robot must be against the pond wall before shooting a duck and the motors on the robot were rather weak making it essential we keep the weight of our mechanisms to a minimum.\nAfter testing out several design archetypes we settled on a motorized lever arm. This would allow us to quickly shoot ducks as soon as hitting the wall of the pond and it would be overall a very lightweight and compact mechanism. We ended up going through seven versions of tweaking various gear rations and arm lengths before we finally settled on the model we used. Here is the link to the cad for anyone interest: CAD Model - Onshape\nProgramming Every group was provided with very basic but working example code. However, this code was very messy and extremely slow which caused me to decide to rewrite it from scratch. One of the biggest issues with the example code is that they do not use a full PID, instead they just use a P value. While this works fine for the majority of robots, if you wanted to go faster than about 30% speed a true PID implementation is required.\nState Machine Architecture I structured the entire program around a state machine with six states: START, RESTART, PATH, SHOOT, TURN, and DONE. This made the code significantly cleaner and easier to debug compared to the tangled mess of if-else statements in the example code. Each state has its own dedicated function that handles exactly what needs to happen in that phase of the run.\nThe robot starts in START, waiting for a button press. Once triggered, it transitions to PATH where the line following happens. When the bump sensors detect the wall, it moves to SHOOT, fires the duck launcher mechanism, then enters TURN to do a 180-degree spin. After turning, it goes back to PATH to return home. On the second bump (hitting the bonus cups), it transitions to DONE and waits for a restart.\nFull PID Implementation The heart of the line following is a proper PID controller. We tuned our constants to KP = 0.05, KI = 0.001, and KD = 0.01 which allowed us to run at 90% motor speed while still tracking the line accurately. The key improvement over the example code was using actual time deltas for the integral and derivative calculations rather than assuming a fixed loop time.\nfloat dt = (currentTime - lastPIDTime) / 1000.0; // Convert to seconds int error = linePos - GOAL; float P = KP * error; integral += error * dt; integral = constrain(integral, -1000, 1000); // Anti-windup float I = KI * integral; float derivative = (error - lastError) / dt; float D = KD * derivative; float motor_speed_delta = P + I + D; The integral term includes anti-windup clamping to prevent it from accumulating too much error when the robot is off the line for extended periods. We also reset the PID state (error, integral, and timing) whenever transitioning between states to prevent any weird behavior from stale values.\nSensor Integration We used a BNO055 IMU for heading information, though in the final version we primarily relied on encoder-based turning. The 180-degree turn is calculated using encoder counts rather than the gyro, which turned out to be more reliable and consistent. The bump sensors on the front detect when we hit the pond wall, triggering the shooting sequence.\nThe line sensors required calibration values that we determined through testing. Each of the 8 sensors has its own min/max calibration range since they all have slightly different sensitivities. This calibration was critical for consistent line detection across different lighting conditions in the competition arena.\nShooter Control The shooting mechanism is dead simple - just a digital pin that triggers the motorized lever arm. A quick HIGH pulse for 300ms is all it takes to launch a duck into the pond. We added small delays before and after to ensure clean activation and to let the mechanism settle before moving again.\nVideo of our Final run ","permalink":"http://localhost:1313/posts/duck-launcher/","summary":"How we made the highest scoring duck launcher.","title":"Duck Launcher"},{"content":" Hardware ESP32-C3 Super Mini Force Sensitive Resistor (FSR) 10K ohm Resistor 3D-Printed Case As I often use ESP32-C3 Super Minis in a lot of my projects due to their extremely small size I had already designed a slim case for them which worked prefectly for this application. The case can be found here on my MakerWorld Profile Page.\nWiring The wiring was very simple, I just soldered one pin of the FSR to 3.3v and then the other pin to a analog pin, in my case pin 4, with the resistor connecting pin 4 and ground.\nSoftware Using Esphome I wrote a basic yaml code to publish a resistor value as well as a binary occupancy value to HomeAssistant that can be found here.\n","permalink":"http://localhost:1313/posts/bed-occupancy-sensor/","summary":"Low cost bed occupancy sensor made with an esp32-c3 super mini and a $10 resistor.","title":"Bed Occupancy Sensor"},{"content":" I wanted an automated blind solution that wouldn\u0026rsquo;t rely on cloud services or expensive commercial products. By repurposing an IKEA roller shades and designing my own controller system, I was able to build a cheap local solution.\nHardware The smart blind consists of four main components:\n28BYJ-48 stepper motor ULN2003 stepper motor driver board ESP32 microcontroller IKEA roller shade I chose these because they were very cheap off of Amazon or Aliexpress and because the ULN2003 was supported by Esphome\u0026rsquo;s stepper component which I was planning on using to program the esp32.\n3D-Printed Case To mount and house the motor and eletronics I designed a 3d printed case in Fusion360. This was my first time cading gears so it took me a bit to get the correct gear ration that would allow the motor to have enough torque to raise the blinds without skipping. After that it was just a matter of blocking out where each component would go and build the case around them.\nWiring The wiring for the ULN2003 was rather straight forward and only needed 4 wires connected to the esp32 and then power and ground for both the driver and esp32\nSoftware To test that everything was working I wrote a quick arduino program to spin the motor in both directions for a few seconds. After confirming my wiring was correct and the code ran I started to write the Esphome code. During this process, I discovered that RoadKillUK had published a Github that was very similar to what I was trying to accomplish. I only had to modify the code slightly to work with an esp32 but it was pretty much perfect.\nUsage \u0026amp; Future Improvements I\u0026rsquo;ve been running the blind for a little over a year now and have had no issue with it so far. There are a few things that I would change if I made a second version. First, the blinds are slow, they take over a minuet to raise/lower about 3 feet. Second, the stepper motor loses its memory of the blind position if it loses power and will need to be re-homed.\n","permalink":"http://localhost:1313/posts/smart-blinds-v1/","summary":"Cheap, simple and effective smart blinds made from and old IKEA roller shades and a few electronic components.","title":"Smart Blinds"},{"content":"I’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\nMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003eI’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\u003c/p\u003e\n\u003cp\u003eMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\u003c/p\u003e","title":"About"},{"content":" Duck Launcher Final At UCF every freshman engineering student are split into groups of four and are tasked with designing and programming a TI-RSLK robot to score as many little rubber ducks in the \u0026ldquo;pond\u0026rdquo; as fast as possible by following a black line to the pond.\nThe pond is a large pentagon in the middle of 5 tracks that teams are trying to score into. There are 3 zones in pond, each getting progressively smaller and worth more points; 100, 300, and 500 respectively. There are also penalty cups, the cups closest to the black line and are a time penalty if hit, and bonus cups which are at the start line and can be hit on the way back for a 50 point bonus every time.\nDesign Our main design goal was to score in the 500 point section as quickly as possible. We really want to get cycle times to be as quick as possible as we were worried about the small size of the center 500 point ring filling up and preventing us from scoring all the points possible. Some restraints we had to follow were that the robot must be against the pond wall before shooting a duck and the motors on the robot were rather weak making it essential we keep the weight of our mechanisms to a minimum.\nAfter testing out several design archetypes we settled on a motorized lever arm. This would allow us to quickly shoot ducks as soon as hitting the wall of the pond and it would be overall a very lightweight and compact mechanism. We ended up going through seven versions of tweaking various gear rations and arm lengths before we finally settled on the model we used. Here is the link to the cad for anyone interest: CAD Model - Onshape\nProgramming Every group was provided with very basic but working example code. However, this code was very messy and extremely slow which caused me to decide to rewrite it from scratch. One of the biggest issues with the example code is that they do not use a full PID, instead they just use a P value. While this works fine for the majority of robots, if you wanted to go faster than about 30% speed a true PID implementation is required.\nState Machine Architecture I structured the entire program around a state machine with six states: START, RESTART, PATH, SHOOT, TURN, and DONE. This made the code significantly cleaner and easier to debug which I will give credit to the example code for doing partially correct. Each state has its own dedicated function that handles exactly what needs to happen in that phase of the run.\nThe robot starts in START, waiting for a button press. Once triggered, it transitions to PATH where the line following happens. When the bump sensors detect the wall, it moves to SHOOT, fires the duck launcher mechanism, then enters TURN to do a 180-degree spin. After turning, it goes back to PATH to return home. On the second bump which is hitting the robot resetters hand for faster reset times, it transitions to DONE and waits for a restart by pressing the front bumper again.\nFull PID Implementation The heart of the line following is a proper PID controller. We tuned our constants to KP = 0.05, KI = 0.001, and KD = 0.01 which allowed us to run at 90% motor speed while still tracking the line accurately. The key improvement over the example code was using actual time deltas for the integral and derivative calculations rather than assuming a fixed loop time.\nfloat dt = (currentTime - lastPIDTime) / 1000.0; // Convert to seconds int error = linePos - GOAL; float P = KP * error; integral += error * dt; integral = constrain(integral, -1000, 1000); // Anti-windup float I = KI * integral; float derivative = (error - lastError) / dt; float D = KD * derivative; float motor_speed_delta = P + I + D; The integral term includes anti-windup clamping to prevent it from accumulating too much error when the robot is off the line for extended periods. We also reset the PID state (error, integral, and timing) whenever transitioning between states to prevent any weird behavior from stale values.\nSensor Integration We used a BNO055 IMU for heading information, though in the final version we primarily relied on encoder-based turning. The 180-degree turn is calculated using encoder counts rather than the gyro, which turned out to be more reliable and consistent. The bump sensors on the front detect when we hit the pond wall, triggering the shooting sequence.\nThe line sensors required calibration values that we determined through testing. Each of the 8 sensors has its own min/max calibration range since they all have slightly different sensitivities. This calibration was critical for consistent line detection across different lighting conditions in the competition arena.\nShooter Control The shooting mechanism is dead simple - just a digital pin that triggers the motorized lever arm. A quick HIGH pulse for 300ms is all it takes to launch a duck into the pond. We added small delays before and after to ensure clean activation and to let the mechanism settle before moving again.\nVideo of our Final run ","permalink":"http://localhost:1313/posts/duck-launcher/","summary":"How we made the highest scoring duck launcher.","title":"Duck Launcher"},{"content":" Hardware ESP32-C3 Super Mini Force Sensitive Resistor (FSR) 10K ohm Resistor 3D-Printed Case As I often use ESP32-C3 Super Minis in a lot of my projects due to their extremely small size I had already designed a slim case for them which worked prefectly for this application. The case can be found here on my MakerWorld Profile Page.\nWiring The wiring was very simple, I just soldered one pin of the FSR to 3.3v and then the other pin to a analog pin, in my case pin 4, with the resistor connecting pin 4 and ground.\nSoftware Using Esphome I wrote a basic yaml code to publish a resistor value as well as a binary occupancy value to HomeAssistant that can be found here.\n","permalink":"http://localhost:1313/posts/bed-occupancy-sensor/","summary":"Low cost bed occupancy sensor made with an esp32-c3 super mini and a $10 resistor.","title":"Bed Occupancy Sensor"},{"content":" I wanted an automated blind solution that wouldn\u0026rsquo;t rely on cloud services or expensive commercial products. By repurposing an IKEA roller shades and designing my own controller system, I was able to build a cheap local solution.\nHardware The smart blind consists of four main components:\n28BYJ-48 stepper motor ULN2003 stepper motor driver board ESP32 microcontroller IKEA roller shade I chose these because they were very cheap off of Amazon or Aliexpress and because the ULN2003 was supported by Esphome\u0026rsquo;s stepper component which I was planning on using to program the esp32.\n3D-Printed Case To mount and house the motor and eletronics I designed a 3d printed case in Fusion360. This was my first time cading gears so it took me a bit to get the correct gear ration that would allow the motor to have enough torque to raise the blinds without skipping. After that it was just a matter of blocking out where each component would go and build the case around them.\nWiring The wiring for the ULN2003 was rather straight forward and only needed 4 wires connected to the esp32 and then power and ground for both the driver and esp32\nSoftware To test that everything was working I wrote a quick arduino program to spin the motor in both directions for a few seconds. After confirming my wiring was correct and the code ran I started to write the Esphome code. During this process, I discovered that RoadKillUK had published a Github that was very similar to what I was trying to accomplish. I only had to modify the code slightly to work with an esp32 but it was pretty much perfect.\nUsage \u0026amp; Future Improvements I\u0026rsquo;ve been running the blind for a little over a year now and have had no issue with it so far. There are a few things that I would change if I made a second version. First, the blinds are slow, they take over a minuet to raise/lower about 3 feet. Second, the stepper motor loses its memory of the blind position if it loses power and will need to be re-homed.\n","permalink":"http://localhost:1313/posts/smart-blinds-v1/","summary":"Cheap, simple and effective smart blinds made from and old IKEA roller shades and a few electronic components.","title":"Smart Blinds"},{"content":"I’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\nMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003eI’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\u003c/p\u003e\n\u003cp\u003eMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\u003c/p\u003e","title":"About"},{"content":" Duck Launcher Final At UCF every freshman engineering student are split into groups of four and are tasked with designing and programming a TI-RSLK robot to score as many little rubber ducks in the \u0026ldquo;pond\u0026rdquo; as fast as possible by following a black line to the pond.\nThe pond is a large pentagon in the middle of 5 tracks that teams are trying to score into. There are 3 zones in pond, each getting progressively smaller and worth more points; 100, 300, and 500 respectively. There are also penalty cups, the cups closest to the black line and are a time penalty if hit, and bonus cups which are at the start line and can be hit on the way back for a 50 point bonus every time.\nDesign Our main design goal was to score in the 500 point section as quickly as possible. We really want to get cycle times to be as quick as possible as we were worried about the small size of the center 500 point ring filling up and preventing us from scoring all the points possible. Some restraints we had to follow were that the robot must be against the pond wall before shooting a duck and the motors on the robot were rather weak making it essential we keep the weight of our mechanisms to a minimum.\nAfter testing out several design archetypes we settled on a motorized lever arm. This would allow us to quickly shoot ducks as soon as hitting the wall of the pond and it would be overall a very lightweight and compact mechanism. We ended up going through seven versions of tweaking various gear rations and arm lengths before we finally settled on the model we used. Here is the link to the cad for anyone interest: CAD Model - Onshape\nProgramming Every group was provided with very basic but working example code. However, this code was very messy and extremely slow which caused me to decide to rewrite it from scratch. One of the biggest issues with the example code is that they do not use a full PID, instead they just use a P value. While this works fine for the majority of robots, if you wanted to go faster than about 30% speed a true PID implementation is required.\nState Machine Architecture I structured the entire program around a state machine with six states: START, RESTART, PATH, SHOOT, TURN, and DONE. This made the code significantly cleaner and easier to debug which I will give credit to the example code for doing partially correct. Each state has its own dedicated function that handles exactly what needs to happen in that phase of the run.\nThe robot starts in START, waiting for a button press. Once triggered, it transitions to PATH where the line following happens. When the bump sensors detect the wall, it moves to SHOOT, fires the duck launcher mechanism, then enters TURN to do a 180-degree spin. After turning, it goes back to PATH to return home. On the second bump which is hitting the robot resetters hand for faster reset times, it transitions to DONE and waits for a restart by pressing the front bumper again.\nFull PID Implementation The heart of the line following is a proper PID controller. We tuned our constants to KP = 0.05, KI = 0.001, and KD = 0.01 which allowed us to run at 90% motor speed while still tracking the line accurately. The key improvement over the example code was using actual time deltas for the integral and derivative calculations rather than assuming a fixed loop time.\nfloat dt = (currentTime - lastPIDTime) / 1000.0; // Convert to seconds int error = linePos - GOAL; float P = KP * error; integral += error * dt; integral = constrain(integral, -1000, 1000); // Anti-windup float I = KI * integral; float derivative = (error - lastError) / dt; float D = KD * derivative; float motor_speed_delta = P + I + D; The integral term includes anti-windup clamping to prevent it from accumulating too much error when the robot is off the line for extended periods. We also reset the PID state (error, integral, and timing) whenever transitioning between states to prevent any weird behavior from stale values.\nSensor Integration We used a BNO055 IMU for heading information, though in the final version we primarily relied on encoder-based turning. The 180-degree turn is calculated using encoder counts rather than the gyro, which turned out to be more reliable and consistent. The bump sensors on the front detect when we hit the pond wall, triggering the shooting sequence.\nThe line sensors required calibration values that we determined through testing. Each of the 8 sensors has its own min/max calibration range since they all have slightly different sensitivities. This calibration was critical for consistent line detection across different lighting conditions in the competition arena.\nShooter Control The shooting mechanism is dead simple - just a digital pin that triggers the motorized lever arm. A quick HIGH pulse for 300ms is all it takes to launch a duck into the pond. We added small delays before and after to ensure clean activation and to let the mechanism settle before moving again.\nVideo of our Final run ","permalink":"http://localhost:1313/posts/duck-launcher/","summary":"How we made the highest scoring duck launcher.","title":"Duck Launcher"},{"content":" Hardware ESP32-C3 Super Mini Force Sensitive Resistor (FSR) 10K ohm Resistor 3D-Printed Case As I often use ESP32-C3 Super Minis in a lot of my projects due to their extremely small size I had already designed a slim case for them which worked prefectly for this application. The case can be found here on my MakerWorld Profile Page.\nWiring The wiring was very simple, I just soldered one pin of the FSR to 3.3v and then the other pin to a analog pin, in my case pin 4, with the resistor connecting pin 4 and ground.\nSoftware Using Esphome I wrote a basic yaml code to publish a resistor value as well as a binary occupancy value to HomeAssistant that can be found here.\n","permalink":"http://localhost:1313/posts/bed-occupancy-sensor/","summary":"Low cost bed occupancy sensor made with an esp32-c3 super mini and a $10 resistor.","title":"Bed Occupancy Sensor"},{"content":" I wanted an automated blind solution that wouldn\u0026rsquo;t rely on cloud services or expensive commercial products. By repurposing an IKEA roller shades and designing my own controller system, I was able to build a cheap local solution.\nHardware The smart blind consists of four main components:\n28BYJ-48 stepper motor ULN2003 stepper motor driver board ESP32 microcontroller IKEA roller shade I chose these because they were very cheap off of Amazon or Aliexpress and because the ULN2003 was supported by Esphome\u0026rsquo;s stepper component which I was planning on using to program the esp32.\n3D-Printed Case To mount and house the motor and eletronics I designed a 3d printed case in Fusion360. This was my first time cading gears so it took me a bit to get the correct gear ration that would allow the motor to have enough torque to raise the blinds without skipping. After that it was just a matter of blocking out where each component would go and build the case around them.\nWiring The wiring for the ULN2003 was rather straight forward and only needed 4 wires connected to the esp32 and then power and ground for both the driver and esp32\nSoftware To test that everything was working I wrote a quick arduino program to spin the motor in both directions for a few seconds. After confirming my wiring was correct and the code ran I started to write the Esphome code. During this process, I discovered that RoadKillUK had published a Github that was very similar to what I was trying to accomplish. I only had to modify the code slightly to work with an esp32 but it was pretty much perfect.\nUsage \u0026amp; Future Improvements I\u0026rsquo;ve been running the blind for a little over a year now and have had no issue with it so far. There are a few things that I would change if I made a second version. First, the blinds are slow, they take over a minuet to raise/lower about 3 feet. Second, the stepper motor loses its memory of the blind position if it loses power and will need to be re-homed.\n","permalink":"http://localhost:1313/posts/smart-blinds-v1/","summary":"Cheap, simple and effective smart blinds made from and old IKEA roller shades and a few electronic components.","title":"Smart Blinds"},{"content":"I’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\nMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003eI’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\u003c/p\u003e\n\u003cp\u003eMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\u003c/p\u003e","title":"About"},{"content":" Duck Launcher Final At UCF every freshman engineering student are split into groups of four and are tasked with designing and programming a TI-RSLK robot to score as many little rubber ducks in the \u0026ldquo;pond\u0026rdquo; as fast as possible by following a black line to the pond.\nThe pond is a large pentagon in the middle of 5 tracks that teams are trying to score into. There are 3 zones in pond, each getting progressively smaller and worth more points; 100, 300, and 500 respectively. There are also penalty cups, the cups closest to the black line and are a time penalty if hit, and bonus cups which are at the start line and can be hit on the way back for a 50 point bonus every time.\nDesign Our main design goal was to score in the 500 point section as quickly as possible. We really want to get cycle times to be as quick as possible as we were worried about the small size of the center 500 point ring filling up and preventing us from scoring all the points possible. Some restraints we had to follow were that the robot must be against the pond wall before shooting a duck and the motors on the robot were rather weak making it essential we keep the weight of our mechanisms to a minimum.\nAfter testing out several design archetypes we settled on a motorized lever arm. This would allow us to quickly shoot ducks as soon as hitting the wall of the pond and it would be overall a very lightweight and compact mechanism. We ended up going through seven versions of tweaking various gear rations and arm lengths before we finally settled on the model we used. Here is the link to the cad for anyone interest: CAD Model - Onshape\nProgramming Every group was provided with very basic but working example code. However, this code was very messy and extremely slow which caused me to decide to rewrite it from scratch. One of the biggest issues with the example code is that they do not use a full PID, instead they just use a P value. While this works fine for the majority of robots, if you wanted to go faster than about 30% speed a true PID implementation is required.\nState Machine Architecture I structured the program around a state machine with six states: START, RESTART, PATH, SHOOT, TURN, and DONE. This made the code significantly cleaner and easier to debug which I will give credit to the example code for doing partially correct. Each state has its own dedicated function that handles exactly what needs to happen in that phase of the run.\nThe robot starts in START, waiting for a button press. Once triggered, it transitions to PATH where the line following happens. When the bump sensors detect the wall, it moves to SHOOT, fires the duck launcher mechanism, then enters TURN to do a 180-degree spin. After turning, it goes back to PATH to return home. On the second bump which is hitting the robot resetters hand for faster reset times, it transitions to DONE and waits for a restart by pressing the front bumper again.\nFull PID Implementation The heart of the line following is a proper PID controller. We tuned our constants to KP = 0.05, KI = 0.001, and KD = 0.01 which allowed us to run at 90% motor speed while still tracking the line accurately. The key improvement over the example code was using actual time deltas for the integral and derivative calculations rather than assuming a fixed loop time.\nfloat dt = (currentTime - lastPIDTime) / 1000.0; // Convert to seconds int error = linePos - GOAL; float P = KP * error; integral += error * dt; integral = constrain(integral, -1000, 1000); // Anti-windup float I = KI * integral; float derivative = (error - lastError) / dt; float D = KD * derivative; float motor_speed_delta = P + I + D; The integral term includes anti-windup clamping to prevent it from accumulating too much error when the robot is off the line for extended periods. We also reset the PID state (error, integral, and timing) whenever transitioning between states to prevent any weird behavior from stale values.\nSensor Integration We used a BNO055 IMU for heading information, though in the final version we primarily relied on encoder-based turning. The 180-degree turn is calculated using encoder counts rather than the gyro, which turned out to be more reliable and consistent. The bump sensors on the front detect when we hit the pond wall, triggering the shooting sequence.\nThe line sensors required calibration values that we determined through testing. Each of the 8 sensors has its own min/max calibration range since they all have slightly different sensitivities. This calibration was critical for consistent line detection across different lighting conditions in the competition arena.\nShooter Control The shooting mechanism is dead simple - just a digital pin that triggers the motorized lever arm. A quick HIGH pulse for 300ms is all it takes to launch a duck into the pond. We added small delays before and after to ensure clean activation and to let the mechanism settle before moving again.\nVideo of our Final run ","permalink":"http://localhost:1313/posts/duck-launcher/","summary":"How we made the highest scoring duck launcher.","title":"Duck Launcher"},{"content":" Hardware ESP32-C3 Super Mini Force Sensitive Resistor (FSR) 10K ohm Resistor 3D-Printed Case As I often use ESP32-C3 Super Minis in a lot of my projects due to their extremely small size I had already designed a slim case for them which worked prefectly for this application. The case can be found here on my MakerWorld Profile Page.\nWiring The wiring was very simple, I just soldered one pin of the FSR to 3.3v and then the other pin to a analog pin, in my case pin 4, with the resistor connecting pin 4 and ground.\nSoftware Using Esphome I wrote a basic yaml code to publish a resistor value as well as a binary occupancy value to HomeAssistant that can be found here.\n","permalink":"http://localhost:1313/posts/bed-occupancy-sensor/","summary":"Low cost bed occupancy sensor made with an esp32-c3 super mini and a $10 resistor.","title":"Bed Occupancy Sensor"},{"content":" I wanted an automated blind solution that wouldn\u0026rsquo;t rely on cloud services or expensive commercial products. By repurposing an IKEA roller shades and designing my own controller system, I was able to build a cheap local solution.\nHardware The smart blind consists of four main components:\n28BYJ-48 stepper motor ULN2003 stepper motor driver board ESP32 microcontroller IKEA roller shade I chose these because they were very cheap off of Amazon or Aliexpress and because the ULN2003 was supported by Esphome\u0026rsquo;s stepper component which I was planning on using to program the esp32.\n3D-Printed Case To mount and house the motor and eletronics I designed a 3d printed case in Fusion360. This was my first time cading gears so it took me a bit to get the correct gear ration that would allow the motor to have enough torque to raise the blinds without skipping. After that it was just a matter of blocking out where each component would go and build the case around them.\nWiring The wiring for the ULN2003 was rather straight forward and only needed 4 wires connected to the esp32 and then power and ground for both the driver and esp32\nSoftware To test that everything was working I wrote a quick arduino program to spin the motor in both directions for a few seconds. After confirming my wiring was correct and the code ran I started to write the Esphome code. During this process, I discovered that RoadKillUK had published a Github that was very similar to what I was trying to accomplish. I only had to modify the code slightly to work with an esp32 but it was pretty much perfect.\nUsage \u0026amp; Future Improvements I\u0026rsquo;ve been running the blind for a little over a year now and have had no issue with it so far. There are a few things that I would change if I made a second version. First, the blinds are slow, they take over a minuet to raise/lower about 3 feet. Second, the stepper motor loses its memory of the blind position if it loses power and will need to be re-homed.\n","permalink":"http://localhost:1313/posts/smart-blinds-v1/","summary":"Cheap, simple and effective smart blinds made from and old IKEA roller shades and a few electronic components.","title":"Smart Blinds"},{"content":"I’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\nMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003eI’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\u003c/p\u003e\n\u003cp\u003eMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\u003c/p\u003e","title":"About"},{"content":" Duck Launcher Final At UCF every freshman engineering student are split into groups of four and are tasked with designing and programming a TI-RSLK robot to score as many little rubber ducks in the \u0026ldquo;pond\u0026rdquo; as fast as possible by following a black line to the pond.\nThe pond is a large pentagon in the middle of 5 tracks that teams are trying to score into. There are 3 zones in pond, each getting progressively smaller and worth more points; 100, 300, and 500 respectively. There are also penalty cups, the cups closest to the black line and are a time penalty if hit, and bonus cups which are at the start line and can be hit on the way back for a 50 point bonus every time.\nDesign Our main design goal was to score in the 500 point section as quickly as possible. We really want to get cycle times to be as quick as possible as we were worried about the small size of the center 500 point ring filling up and preventing us from scoring all the points possible. Some restraints we had to follow were that the robot must be against the pond wall before shooting a duck and the motors on the robot were rather weak making it essential we keep the weight of our mechanisms to a minimum.\nAfter testing out several design archetypes we settled on a motorized lever arm. This would allow us to quickly shoot ducks as soon as hitting the wall of the pond and it would be overall a very lightweight and compact mechanism. We ended up going through seven versions of tweaking various gear rations and arm lengths before we finally settled on the model we used. Here is the link to the cad for anyone interest: CAD Model - Onshape\nProgramming Every group was provided with very basic but working example code. However, this code was very messy and extremely slow which caused me to decide to rewrite it from scratch. One of the biggest issues with the example code is that they do not use a full PID, instead they just use a P value. While this works fine for the majority of robots, if you wanted to go faster than about 30% speed a true PID implementation is required.\nState Machine Architecture I structured the program around a state machine with six states: START, RESTART, PATH, SHOOT, TURN, and DONE. This made the code significantly cleaner and easier to debug which I will give credit to the example code for doing partially correct. Each state has its own dedicated function that handles exactly what needs to happen in that phase of the run.\nThe robot starts in START, waiting for a button press. Once triggered, it transitions to PATH where the line following happens. When the bump sensors detect the wall, it moves to SHOOT, fires the duck launcher mechanism, then enters TURN to do a 180-degree spin. After turning, it goes back to PATH to return home. On the second bump which is hitting the robot resetters hand for faster reset times, it transitions to DONE and waits for a restart by pressing the front bumper again.\nFull PID Implementation A proper PID controller is needed to consistently follow the line at faster speeds. We tuned our constants to KP = 0.05, KI = 0.001, and KD = 0.01 which allowed us to run at 90% motor speed while still tracking the line accurately. The key improvement over the example code was using actual time deltas for the integral and derivative calculations rather than assuming a fixed loop time.\nfloat dt = (currentTime - lastPIDTime) / 1000.0; // Convert to seconds int error = linePos - GOAL; float P = KP * error; integral += error * dt; integral = constrain(integral, -1000, 1000); // Anti-windup float I = KI * integral; float derivative = (error - lastError) / dt; float D = KD * derivative; float motor_speed_delta = P + I + D; The integral term includes anti-windup clamping to prevent it from accumulating too much error when the robot is off the line for extended periods. We also reset the PID state (error, integral, and timing) whenever transitioning between states to prevent any weird behavior from stale values.\nSensor Integration We used a BNO055 IMU for heading information, though in the final version we primarily relied on encoder-based turning. The 180-degree turn is calculated using encoder counts rather than the gyro, which turned out to be more reliable and consistent. The bump sensors on the front detect when we hit the pond wall, triggering the shooting sequence.\nThe line sensors required calibration values that we determined through testing. Each of the 8 sensors has its own min/max calibration range since they all have slightly different sensitivities. This calibration was critical for consistent line detection across different lighting conditions in the competition arena.\nShooter Control The shooting mechanism is dead simple - just a digital pin that triggers the motorized lever arm. A quick HIGH pulse for 300ms is all it takes to launch a duck into the pond. We added small delays before and after to ensure clean activation and to let the mechanism settle before moving again.\nVideo of our Final run ","permalink":"http://localhost:1313/posts/duck-launcher/","summary":"How we made the highest scoring duck launcher.","title":"Duck Launcher"},{"content":" Hardware ESP32-C3 Super Mini Force Sensitive Resistor (FSR) 10K ohm Resistor 3D-Printed Case As I often use ESP32-C3 Super Minis in a lot of my projects due to their extremely small size I had already designed a slim case for them which worked prefectly for this application. The case can be found here on my MakerWorld Profile Page.\nWiring The wiring was very simple, I just soldered one pin of the FSR to 3.3v and then the other pin to a analog pin, in my case pin 4, with the resistor connecting pin 4 and ground.\nSoftware Using Esphome I wrote a basic yaml code to publish a resistor value as well as a binary occupancy value to HomeAssistant that can be found here.\n","permalink":"http://localhost:1313/posts/bed-occupancy-sensor/","summary":"Low cost bed occupancy sensor made with an esp32-c3 super mini and a $10 resistor.","title":"Bed Occupancy Sensor"},{"content":" I wanted an automated blind solution that wouldn\u0026rsquo;t rely on cloud services or expensive commercial products. By repurposing an IKEA roller shades and designing my own controller system, I was able to build a cheap local solution.\nHardware The smart blind consists of four main components:\n28BYJ-48 stepper motor ULN2003 stepper motor driver board ESP32 microcontroller IKEA roller shade I chose these because they were very cheap off of Amazon or Aliexpress and because the ULN2003 was supported by Esphome\u0026rsquo;s stepper component which I was planning on using to program the esp32.\n3D-Printed Case To mount and house the motor and eletronics I designed a 3d printed case in Fusion360. This was my first time cading gears so it took me a bit to get the correct gear ration that would allow the motor to have enough torque to raise the blinds without skipping. After that it was just a matter of blocking out where each component would go and build the case around them.\nWiring The wiring for the ULN2003 was rather straight forward and only needed 4 wires connected to the esp32 and then power and ground for both the driver and esp32\nSoftware To test that everything was working I wrote a quick arduino program to spin the motor in both directions for a few seconds. After confirming my wiring was correct and the code ran I started to write the Esphome code. During this process, I discovered that RoadKillUK had published a Github that was very similar to what I was trying to accomplish. I only had to modify the code slightly to work with an esp32 but it was pretty much perfect.\nUsage \u0026amp; Future Improvements I\u0026rsquo;ve been running the blind for a little over a year now and have had no issue with it so far. There are a few things that I would change if I made a second version. First, the blinds are slow, they take over a minuet to raise/lower about 3 feet. Second, the stepper motor loses its memory of the blind position if it loses power and will need to be re-homed.\n","permalink":"http://localhost:1313/posts/smart-blinds-v1/","summary":"Cheap, simple and effective smart blinds made from and old IKEA roller shades and a few electronic components.","title":"Smart Blinds"},{"content":"I’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\nMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003eI’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\u003c/p\u003e\n\u003cp\u003eMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\u003c/p\u003e","title":"About"},{"content":" Duck Launcher Final At UCF every freshman engineering student are split into groups of four and are tasked with designing and programming a TI-RSLK robot to score as many little rubber ducks in the \u0026ldquo;pond\u0026rdquo; as fast as possible by following a black line to the pond.\nThe pond is a large pentagon in the middle of 5 tracks that teams are trying to score into. There are 3 zones in pond, each getting progressively smaller and worth more points; 100, 300, and 500 respectively. There are also penalty cups, the cups closest to the black line and are a time penalty if hit, and bonus cups which are at the start line and can be hit on the way back for a 50 point bonus every time.\nDesign Our main design goal was to score in the 500 point section as quickly as possible. We really want to get cycle times to be as quick as possible as we were worried about the small size of the center 500 point ring filling up and preventing us from scoring all the points possible. Some restraints we had to follow were that the robot must be against the pond wall before shooting a duck and the motors on the robot were rather weak making it essential we keep the weight of our mechanisms to a minimum.\nAfter testing out several design archetypes we settled on a motorized lever arm. This would allow us to quickly shoot ducks as soon as hitting the wall of the pond and it would be overall a very lightweight and compact mechanism. We ended up going through seven versions of tweaking various gear rations and arm lengths before we finally settled on the model we used. Here is the link to the cad for anyone interest: CAD Model - Onshape\nProgramming Every group was provided with very basic but working example code. However, this code was very messy and extremely slow which caused me to decide to rewrite it from scratch. One of the biggest issues with the example code is that they do not use a full PID, instead they just use a P value. While this works fine for the majority of robots, if you wanted to go faster than about 30% speed a true PID implementation is required.\nState Machine Architecture I structured the program around a state machine with six states: START, RESTART, PATH, SHOOT, TURN, and DONE. This made the code significantly cleaner and easier to debug which I will give credit to the example code for doing partially correct. Each state has its own dedicated function that handles exactly what needs to happen in that phase of the run.\nThe robot starts in START, waiting for a button press. Once triggered, it transitions to PATH where the line following happens. When the bump sensors detect the wall, it moves to SHOOT, fires the duck launcher mechanism, then enters TURN to do a 180-degree spin. After turning, it goes back to PATH to return home. On the second bump which is hitting the robot resetters hand for faster reset times, it transitions to DONE and waits for a restart by pressing the front bumper again.\nFull PID Implementation A proper PID controller is needed to consistently follow the line at faster speeds. The key improvement over the example code was using actual time deltas for the integral and derivative calculations rather than assuming a fixed loop time. We tuned our constants to KP = 0.05, KI = 0.001, and KD = 0.01 which allowed us to run at 90% motor speed while still tracking the line accurately. These values differed per robot as they all were in different states of disrepair so we were never able to tune the PID to be as smooth as I wanted.\nfloat dt = (currentTime - lastPIDTime) / 1000.0; // Convert to seconds int error = linePos - GOAL; float P = KP * error; integral += error * dt; integral = constrain(integral, -1000, 1000); // Anti-windup float I = KI * integral; float derivative = (error - lastError) / dt; float D = KD * derivative; float motor_speed_delta = P + I + D; The integral term includes anti-windup clamping to prevent it from accumulating too much error when the robot is off the line for extended periods. We also reset the PID state (error, integral, and timing) whenever transitioning between states to prevent any weird behavior from stale values.\nShooter Control The shooting mechanism was very simple, just a digital pin that triggers a relay to trigger the motorized lever arm. A quick HIGH pulse for 300ms is all it takes to launch a duck into the pond. I added small delays before and after to ensure clean activation and so that we don\u0026rsquo;t brownout the robot which was an issue we had when trying to run both the wheels and shooter motor at the same time.\nVideo of our Final run ","permalink":"http://localhost:1313/posts/duck-launcher/","summary":"How we made the highest scoring duck launcher.","title":"Duck Launcher"},{"content":" Hardware ESP32-C3 Super Mini Force Sensitive Resistor (FSR) 10K ohm Resistor 3D-Printed Case As I often use ESP32-C3 Super Minis in a lot of my projects due to their extremely small size I had already designed a slim case for them which worked prefectly for this application. The case can be found here on my MakerWorld Profile Page.\nWiring The wiring was very simple, I just soldered one pin of the FSR to 3.3v and then the other pin to a analog pin, in my case pin 4, with the resistor connecting pin 4 and ground.\nSoftware Using Esphome I wrote a basic yaml code to publish a resistor value as well as a binary occupancy value to HomeAssistant that can be found here.\n","permalink":"http://localhost:1313/posts/bed-occupancy-sensor/","summary":"Low cost bed occupancy sensor made with an esp32-c3 super mini and a $10 resistor.","title":"Bed Occupancy Sensor"},{"content":" I wanted an automated blind solution that wouldn\u0026rsquo;t rely on cloud services or expensive commercial products. By repurposing an IKEA roller shades and designing my own controller system, I was able to build a cheap local solution.\nHardware The smart blind consists of four main components:\n28BYJ-48 stepper motor ULN2003 stepper motor driver board ESP32 microcontroller IKEA roller shade I chose these because they were very cheap off of Amazon or Aliexpress and because the ULN2003 was supported by Esphome\u0026rsquo;s stepper component which I was planning on using to program the esp32.\n3D-Printed Case To mount and house the motor and eletronics I designed a 3d printed case in Fusion360. This was my first time cading gears so it took me a bit to get the correct gear ration that would allow the motor to have enough torque to raise the blinds without skipping. After that it was just a matter of blocking out where each component would go and build the case around them.\nWiring The wiring for the ULN2003 was rather straight forward and only needed 4 wires connected to the esp32 and then power and ground for both the driver and esp32\nSoftware To test that everything was working I wrote a quick arduino program to spin the motor in both directions for a few seconds. After confirming my wiring was correct and the code ran I started to write the Esphome code. During this process, I discovered that RoadKillUK had published a Github that was very similar to what I was trying to accomplish. I only had to modify the code slightly to work with an esp32 but it was pretty much perfect.\nUsage \u0026amp; Future Improvements I\u0026rsquo;ve been running the blind for a little over a year now and have had no issue with it so far. There are a few things that I would change if I made a second version. First, the blinds are slow, they take over a minuet to raise/lower about 3 feet. Second, the stepper motor loses its memory of the blind position if it loses power and will need to be re-homed.\n","permalink":"http://localhost:1313/posts/smart-blinds-v1/","summary":"Cheap, simple and effective smart blinds made from and old IKEA roller shades and a few electronic components.","title":"Smart Blinds"},{"content":"I’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\nMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003eI’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\u003c/p\u003e\n\u003cp\u003eMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\u003c/p\u003e","title":"About"},{"content":" Duck Launcher Final At UCF every freshman engineering student are split into groups of four and are tasked with designing and programming a TI-RSLK robot to score as many little rubber ducks in the \u0026ldquo;pond\u0026rdquo; as fast as possible by following a black line to the pond.\nThe pond is a large pentagon in the middle of 5 tracks that teams are trying to score into. There are 3 zones in pond, each getting progressively smaller and worth more points; 100, 300, and 500 respectively. There are also penalty cups, the cups closest to the black line and are a time penalty if hit, and bonus cups which are at the start line and can be hit on the way back for a 50 point bonus every time.\nDesign Our main design goal was to score in the 500 point section as quickly as possible. We really want to get cycle times to be as quick as possible as we were worried about the small size of the center 500 point ring filling up and preventing us from scoring all the points possible. Some restraints we had to follow were that the robot must be against the pond wall before shooting a duck and the motors on the robot were rather weak making it essential we keep the weight of our mechanisms to a minimum.\nAfter testing out several design archetypes we settled on a motorized lever arm. This would allow us to quickly shoot ducks as soon as hitting the wall of the pond and it would be overall a very lightweight and compact mechanism. We ended up going through seven versions of tweaking various gear rations and arm lengths before we finally settled on the model we used. Here is the link to the cad for anyone interest: CAD Model - Onshape\nProgramming Every group was provided with very basic but working example code. However, this code was very messy and extremely slow which caused me to decide to rewrite it from scratch. One of the biggest issues with the example code is that they do not use a full PID, instead they just use a P value. While this works fine for the majority of robots, if you wanted to go faster than about 30% speed a true PID implementation is required.\nState Machine Architecture I structured the program around a state machine with six states: START, RESTART, PATH, SHOOT, TURN, and DONE. This made the code significantly cleaner and easier to debug which I will give credit to the example code for doing partially correct. Each state has its own dedicated function that handles exactly what needs to happen in that phase of the run.\nThe robot starts in START, waiting for a button press. Once triggered, it transitions to PATH where the line following happens. When the bump sensors detect the wall, it moves to SHOOT, fires the duck launcher mechanism, then enters TURN to do a 180-degree spin. After turning, it goes back to PATH to return home. On the second bump which is hitting the robot resetters hand for faster reset times, it transitions to DONE and waits for a restart by pressing the front bumper again.\nFull PID Implementation A proper PID controller is needed to consistently follow the line at faster speeds. The key improvement over the example code was using actual time deltas for the integral and derivative calculations rather than assuming a fixed loop time. We tuned our constants to KP = 0.05, KI = 0.001, and KD = 0.01 which allowed us to run at 90% motor speed while still tracking the line accurately. These values differed per robot as they all were in different states of disrepair so we were never able to tune the PID to be as smooth as I wanted.\nfloat dt = (currentTime - lastPIDTime) / 1000.0; // Convert to seconds int error = linePos - GOAL; float P = KP * error; integral += error * dt; integral = constrain(integral, -1000, 1000); // Anti-windup float I = KI * integral; float derivative = (error - lastError) / dt; float D = KD * derivative; float motor_speed_delta = P + I + D; The integral term includes anti-windup clamping to prevent it from accumulating too much error when the robot is off the line for extended periods. We also reset the PID state (error, integral, and timing) whenever transitioning between states to prevent any weird behavior from stale values.\nShooter Control The shooting mechanism was very simple, just a digital pin that triggers a relay to trigger the motorized lever arm. A quick HIGH pulse for 300ms is all it takes to launch a duck into the pond. I added small delays before and after to ensure clean activation and so that we don\u0026rsquo;t brownout the robot which was an issue we had when trying to run both the wheels and shooter motor at the same time.\nVideo of our Final run ","permalink":"http://localhost:1313/posts/duck-launcher/","summary":"How we made the highest scoring duck launcher.","title":"Duck Launcher"},{"content":" Hardware ESP32-C3 Super Mini Force Sensitive Resistor (FSR) 10K ohm Resistor 3D-Printed Case As I often use ESP32-C3 Super Minis in a lot of my projects due to their extremely small size I had already designed a slim case for them which worked prefectly for this application. The case can be found here on my MakerWorld Profile Page.\nWiring The wiring was very simple, I just soldered one pin of the FSR to 3.3v and then the other pin to a analog pin, in my case pin 4, with the resistor connecting pin 4 and ground.\nSoftware Using Esphome I wrote a basic yaml code to publish a resistor value as well as a binary occupancy value to HomeAssistant that can be found here.\n","permalink":"http://localhost:1313/posts/bed-occupancy-sensor/","summary":"Low cost bed occupancy sensor made with an esp32-c3 super mini and a $10 resistor.","title":"Bed Occupancy Sensor"},{"content":" I wanted an automated blind solution that wouldn\u0026rsquo;t rely on cloud services or expensive commercial products. By repurposing an IKEA roller shades and designing my own controller system, I was able to build a cheap local solution.\nHardware The smart blind consists of four main components:\n28BYJ-48 stepper motor ULN2003 stepper motor driver board ESP32 microcontroller IKEA roller shade I chose these because they were very cheap off of Amazon or Aliexpress and because the ULN2003 was supported by Esphome\u0026rsquo;s stepper component which I was planning on using to program the esp32.\n3D-Printed Case To mount and house the motor and eletronics I designed a 3d printed case in Fusion360. This was my first time cading gears so it took me a bit to get the correct gear ration that would allow the motor to have enough torque to raise the blinds without skipping. After that it was just a matter of blocking out where each component would go and build the case around them.\nWiring The wiring for the ULN2003 was rather straight forward and only needed 4 wires connected to the esp32 and then power and ground for both the driver and esp32\nSoftware To test that everything was working I wrote a quick arduino program to spin the motor in both directions for a few seconds. After confirming my wiring was correct and the code ran I started to write the Esphome code. During this process, I discovered that RoadKillUK had published a Github that was very similar to what I was trying to accomplish. I only had to modify the code slightly to work with an esp32 but it was pretty much perfect.\nUsage \u0026amp; Future Improvements I\u0026rsquo;ve been running the blind for a little over a year now and have had no issue with it so far. There are a few things that I would change if I made a second version. First, the blinds are slow, they take over a minuet to raise/lower about 3 feet. Second, the stepper motor loses its memory of the blind position if it loses power and will need to be re-homed.\n","permalink":"http://localhost:1313/posts/smart-blinds-v1/","summary":"Cheap, simple and effective smart blinds made from and old IKEA roller shades and a few electronic components.","title":"Smart Blinds"},{"content":"I’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\nMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003eI’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\u003c/p\u003e\n\u003cp\u003eMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\u003c/p\u003e","title":"About"},{"content":" Duck Launcher Final At UCF every freshman engineering student are split into groups of four and are tasked with designing and programming a TI-RSLK robot to score as many little rubber ducks in the \u0026ldquo;pond\u0026rdquo; as fast as possible by following a black line to the pond.\nThe pond is a large pentagon in the middle of 5 tracks that teams are trying to score into. There are 3 zones in pond, each getting progressively smaller and worth more points; 100, 300, and 500 respectively. There are also penalty cups, the cups closest to the black line and are a time penalty if hit, and bonus cups which are at the start line and can be hit on the way back for a 50 point bonus every time.\nDesign Our main design goal was to score in the 500 point section as quickly as possible. We really want to get cycle times to be as quick as possible as we were worried about the small size of the center 500 point ring filling up and preventing us from scoring all the points possible. Some restraints we had to follow were that the robot must be against the pond wall before shooting a duck and the motors on the robot were rather weak making it essential we keep the weight of our mechanisms to a minimum.\nAfter testing out several design archetypes we settled on a motorized lever arm. This would allow us to quickly shoot ducks as soon as hitting the wall of the pond and it would be overall a very lightweight and compact mechanism. We ended up going through seven versions of tweaking various gear rations and arm lengths before we finally settled on the model we used. Here is the link to the cad for anyone interest: CAD Model - Onshape\nProgramming Every group was provided with very basic but working example code. However, this code was very messy and extremely slow which caused me to decide to rewrite it from scratch. One of the biggest issues with the example code is that they do not use a full PID, instead they just use a P value. While this works fine for the majority of robots, if you wanted to go faster than about 30% speed a true PID implementation is required.\nState Machine Architecture I structured the program around a state machine with six states: START, RESTART, PATH, SHOOT, TURN, and DONE. This made the code significantly cleaner and easier to debug which I will give credit to the example code for doing partially correct. Each state has its own dedicated function that handles exactly what needs to happen in that phase of the run.\nThe robot starts in START, waiting for a button press. Once triggered, it transitions to PATH where the line following happens. When the bump sensors detect the wall, it moves to SHOOT, fires the duck launcher mechanism, then enters TURN to do a 180-degree spin. After turning, it goes back to PATH to return home. On the second bump which is hitting the robot resetters hand for faster reset times, it transitions to DONE and waits for a restart by pressing the front bumper again.\nFull PID Implementation A proper PID controller is needed to consistently follow the line at faster speeds. The key improvement over the example code was using actual time deltas for the integral and derivative calculations rather than assuming a fixed loop time. We tuned our constants to KP = 0.05, KI = 0.001, and KD = 0.01 which allowed us to run at 90% motor speed while still tracking the line accurately. These values differed per robot as they all were in different states of disrepair so we were never able to tune the PID to be as smooth as I wanted.\nfloat dt = (currentTime - lastPIDTime) / 1000.0; // Convert to seconds int error = linePos - GOAL; float P = KP * error; integral += error * dt; integral = constrain(integral, -1000, 1000); // Anti-windup float I = KI * integral; float derivative = (error - lastError) / dt; float D = KD * derivative; float motor_speed_delta = P + I + D; The integral term includes anti-windup clamping to prevent it from accumulating too much error when the robot is off the line for extended periods. We also reset the PID state (error, integral, and timing) whenever transitioning between states to prevent any weird behavior from stale values.\nShooter Control The shooting mechanism was very simple, just a digital pin that triggers a relay to trigger the motorized lever arm. A quick HIGH pulse for 300ms is all it takes to launch a duck into the pond. I added small delays before and after to ensure clean activation and so that we don\u0026rsquo;t brownout the robot which was an issue we had when trying to run both the wheels and shooter motor at the same time.\nRetrospective Video of our Final run ","permalink":"http://localhost:1313/posts/duck-launcher/","summary":"How we made the highest scoring duck launcher.","title":"Duck Launcher"},{"content":" Hardware ESP32-C3 Super Mini Force Sensitive Resistor (FSR) 10K ohm Resistor 3D-Printed Case As I often use ESP32-C3 Super Minis in a lot of my projects due to their extremely small size I had already designed a slim case for them which worked prefectly for this application. The case can be found here on my MakerWorld Profile Page.\nWiring The wiring was very simple, I just soldered one pin of the FSR to 3.3v and then the other pin to a analog pin, in my case pin 4, with the resistor connecting pin 4 and ground.\nSoftware Using Esphome I wrote a basic yaml code to publish a resistor value as well as a binary occupancy value to HomeAssistant that can be found here.\n","permalink":"http://localhost:1313/posts/bed-occupancy-sensor/","summary":"Low cost bed occupancy sensor made with an esp32-c3 super mini and a $10 resistor.","title":"Bed Occupancy Sensor"},{"content":" I wanted an automated blind solution that wouldn\u0026rsquo;t rely on cloud services or expensive commercial products. By repurposing an IKEA roller shades and designing my own controller system, I was able to build a cheap local solution.\nHardware The smart blind consists of four main components:\n28BYJ-48 stepper motor ULN2003 stepper motor driver board ESP32 microcontroller IKEA roller shade I chose these because they were very cheap off of Amazon or Aliexpress and because the ULN2003 was supported by Esphome\u0026rsquo;s stepper component which I was planning on using to program the esp32.\n3D-Printed Case To mount and house the motor and eletronics I designed a 3d printed case in Fusion360. This was my first time cading gears so it took me a bit to get the correct gear ration that would allow the motor to have enough torque to raise the blinds without skipping. After that it was just a matter of blocking out where each component would go and build the case around them.\nWiring The wiring for the ULN2003 was rather straight forward and only needed 4 wires connected to the esp32 and then power and ground for both the driver and esp32\nSoftware To test that everything was working I wrote a quick arduino program to spin the motor in both directions for a few seconds. After confirming my wiring was correct and the code ran I started to write the Esphome code. During this process, I discovered that RoadKillUK had published a Github that was very similar to what I was trying to accomplish. I only had to modify the code slightly to work with an esp32 but it was pretty much perfect.\nUsage \u0026amp; Future Improvements I\u0026rsquo;ve been running the blind for a little over a year now and have had no issue with it so far. There are a few things that I would change if I made a second version. First, the blinds are slow, they take over a minuet to raise/lower about 3 feet. Second, the stepper motor loses its memory of the blind position if it loses power and will need to be re-homed.\n","permalink":"http://localhost:1313/posts/smart-blinds-v1/","summary":"Cheap, simple and effective smart blinds made from and old IKEA roller shades and a few electronic components.","title":"Smart Blinds"},{"content":"I’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\nMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003eI’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\u003c/p\u003e\n\u003cp\u003eMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\u003c/p\u003e","title":"About"},{"content":" Duck Launcher Final At UCF every freshman engineering student is split into groups of four and tasked with designing and programming a TI-RSLK robot to score as many little rubber ducks in the \u0026ldquo;pond\u0026rdquo; as fast as possible by following a black line to the pond within 10 minutes.\nThe pond is a large pentagon in the middle of 5 tracks that teams are trying to score into. There are 3 zones in the pond, each getting progressively smaller and worth more points; 100, 300, and 500 respectively. There are also penalty cups closest to the black line that add a time penalty if hit, and bonus cups at the start line that can be hit on the way back for a 50 point bonus every time.\nDesign Our main design goal was to score in the 500 point section as quickly as possible. We really wanted to get cycle times to be as quick as possible since we were worried about the small size of the center 500 point ring filling up and preventing us from scoring all the points possible. Some constraints we had to follow were that the robot must be against the pond wall before shooting a duck and the motors on the robot were rather weak, making it essential we keep the weight of our mechanisms to a minimum.\nAfter testing out several design archetypes we settled on a motorized lever arm. This allowed us to quickly shoot ducks as soon as we hit the wall of the pond and was overall a very lightweight and compact mechanism. We ended up going through seven versions, tweaking various gear ratios and arm lengths before we finally settled on the model we used. Here is the link to the CAD for anyone interested: CAD Model - Onshape\nProgramming Every group was provided with very basic but working example code. However, this code was very messy and extremely slow which caused me to decide to rewrite it from scratch. One of the biggest issues with the example code is that they do not use a full PID, instead they just use a P value. While this works fine for the majority of robots, if you wanted to go faster than about 30% speed a true PID implementation is required.\nState Machine Architecture I structured the program around a state machine with six states: START, RESTART, PATH, SHOOT, TURN, and DONE. This made the code significantly cleaner and easier to debug which I will give credit to the example code for doing partially correct. Each state has its own dedicated function that handles exactly what needs to happen in that phase of the run.\nThe robot starts in START, waiting for a button press. Once triggered, it transitions to PATH where the line following happens. When the bump sensors detect the wall, it moves to SHOOT, fires the duck launcher mechanism, then enters TURN to do a 180-degree spin. After turning, it goes back to PATH to return home. On the second bump which is hitting the robot resetters hand for faster reset times, it transitions to DONE and waits for a restart by pressing the front bumper again.\nFull PID Implementation A proper PID controller is needed to consistently follow the line at faster speeds. The key improvement over the example code was using actual time deltas for the integral and derivative calculations rather than assuming a fixed loop time. We tuned our constants to KP = 0.05, KI = 0.001, and KD = 0.01 which allowed us to run at 90% motor speed while still tracking the line accurately. These values differed per robot as they all were in different states of disrepair so we were never able to tune the PID to be as smooth as I wanted.\nfloat dt = (currentTime - lastPIDTime) / 1000.0; // Convert to seconds int error = linePos - GOAL; float P = KP * error; integral += error * dt; integral = constrain(integral, -1000, 1000); // Anti-windup float I = KI * integral; float derivative = (error - lastError) / dt; float D = KD * derivative; float motor_speed_delta = P + I + D; The integral term includes anti-windup clamping to prevent it from accumulating too much error when the robot is off the line for extended periods. We also reset the PID state (error, integral, and timing) whenever transitioning between states to prevent any weird behavior from stale values.\nShooter Control The shooting mechanism was very simple, just a digital pin that triggers a relay to trigger the motorized lever arm. A quick HIGH pulse for 300ms is all it takes to launch a duck into the pond. I added small delays before and after to ensure clean activation and so that we don\u0026rsquo;t brownout the robot which was an issue we had when trying to run both the wheels and shooter motor at the same time.\nRetrospective Overall we did great and I\u0026rsquo;m very proud of my team for coming first over two thousand freshman engineers! The average score was probably less than 5k which we crushed scoring 30,500 points with 81 ducks (44 in the 500, 24 in the 300, and 13 in the 100).\nVideo of our Final run ","permalink":"http://localhost:1313/posts/duck-launcher/","summary":"How we made the highest scoring duck launcher.","title":"Duck Launcher"},{"content":" Hardware ESP32-C3 Super Mini Force Sensitive Resistor (FSR) 10K ohm Resistor 3D-Printed Case As I often use ESP32-C3 Super Minis in a lot of my projects due to their extremely small size I had already designed a slim case for them which worked prefectly for this application. The case can be found here on my MakerWorld Profile Page.\nWiring The wiring was very simple, I just soldered one pin of the FSR to 3.3v and then the other pin to a analog pin, in my case pin 4, with the resistor connecting pin 4 and ground.\nSoftware Using Esphome I wrote a basic yaml code to publish a resistor value as well as a binary occupancy value to HomeAssistant that can be found here.\n","permalink":"http://localhost:1313/posts/bed-occupancy-sensor/","summary":"Low cost bed occupancy sensor made with an esp32-c3 super mini and a $10 resistor.","title":"Bed Occupancy Sensor"},{"content":" I wanted an automated blind solution that wouldn\u0026rsquo;t rely on cloud services or expensive commercial products. By repurposing an IKEA roller shades and designing my own controller system, I was able to build a cheap local solution.\nHardware The smart blind consists of four main components:\n28BYJ-48 stepper motor ULN2003 stepper motor driver board ESP32 microcontroller IKEA roller shade I chose these because they were very cheap off of Amazon or Aliexpress and because the ULN2003 was supported by Esphome\u0026rsquo;s stepper component which I was planning on using to program the esp32.\n3D-Printed Case To mount and house the motor and eletronics I designed a 3d printed case in Fusion360. This was my first time cading gears so it took me a bit to get the correct gear ration that would allow the motor to have enough torque to raise the blinds without skipping. After that it was just a matter of blocking out where each component would go and build the case around them.\nWiring The wiring for the ULN2003 was rather straight forward and only needed 4 wires connected to the esp32 and then power and ground for both the driver and esp32\nSoftware To test that everything was working I wrote a quick arduino program to spin the motor in both directions for a few seconds. After confirming my wiring was correct and the code ran I started to write the Esphome code. During this process, I discovered that RoadKillUK had published a Github that was very similar to what I was trying to accomplish. I only had to modify the code slightly to work with an esp32 but it was pretty much perfect.\nUsage \u0026amp; Future Improvements I\u0026rsquo;ve been running the blind for a little over a year now and have had no issue with it so far. There are a few things that I would change if I made a second version. First, the blinds are slow, they take over a minuet to raise/lower about 3 feet. Second, the stepper motor loses its memory of the blind position if it loses power and will need to be re-homed.\n","permalink":"http://localhost:1313/posts/smart-blinds-v1/","summary":"Cheap, simple and effective smart blinds made from and old IKEA roller shades and a few electronic components.","title":"Smart Blinds"},{"content":"I’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\nMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003eI’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\u003c/p\u003e\n\u003cp\u003eMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\u003c/p\u003e","title":"About"},{"content":" Duck Launcher Final At UCF every freshman engineering student is split into groups of four and tasked with designing and programming a TI-RSLK robot to score as many little rubber ducks in the \u0026ldquo;pond\u0026rdquo; as fast as possible by following a black line to the pond within 10 minutes.\nThe pond is a large pentagon in the middle of 5 tracks that teams are trying to score into. There are 3 zones in the pond, each getting progressively smaller and worth more points; 100, 300, and 500 respectively. There are also penalty cups closest to the black line that add a time penalty if hit, and bonus cups at the start line that can be hit on the way back for a 50 point bonus every time.\nDesign Our main design goal was to score in the 500 point section as quickly as possible. We really wanted to get cycle times to be as quick as possible since we were worried about the small size of the center 500 point ring filling up and preventing us from scoring all the points possible. Some constraints we had to follow were that the robot must be against the pond wall before shooting a duck and the motors on the robot were rather weak, making it essential we keep the weight of our mechanisms to a minimum.\nAfter testing out several design archetypes we settled on a motorized lever arm. This allowed us to quickly shoot ducks as soon as we hit the wall of the pond and was overall a very lightweight and compact mechanism. We ended up going through seven versions, tweaking various gear ratios and arm lengths before we finally settled on the model we used. Here is the link to the CAD for anyone interested: CAD Model - Onshape\nProgramming Every group was provided with very basic but working example code. However, this code was very messy and extremely slow which caused me to decide to rewrite it from scratch. One of the biggest issues with the example code is that they do not use a full PID, instead they just use a P value. While this works fine for the majority of robots, if you wanted to go faster than about 30% speed a true PID implementation is required.\nState Machine Architecture I structured the program around a state machine with six states: START, RESTART, PATH, SHOOT, TURN, and DONE. This made the code significantly cleaner and easier to debug which I will give credit to the example code for doing partially correct. Each state has its own dedicated function that handles exactly what needs to happen in that phase of the run.\nThe robot starts in START, waiting for a button press. Once triggered, it transitions to PATH where the line following happens. When the bump sensors detect the wall, it moves to SHOOT, fires the duck launcher mechanism, then enters TURN to do a 180-degree spin. After turning, it goes back to PATH to return home. On the second bump which is hitting the robot resetters hand for faster reset times, it transitions to DONE and waits for a restart by pressing the front bumper again.\nFull PID Implementation A proper PID controller is needed to consistently follow the line at faster speeds. The key improvement over the example code was using actual time deltas for the integral and derivative calculations rather than assuming a fixed loop time. We tuned our constants to KP = 0.05, KI = 0.001, and KD = 0.01 which allowed us to run at 90% motor speed while still tracking the line accurately. These values differed per robot as they all were in different states of disrepair so we were never able to tune the PID to be as smooth as I wanted.\nfloat dt = (currentTime - lastPIDTime) / 1000.0; // Convert to seconds int error = linePos - GOAL; float P = KP * error; integral += error * dt; integral = constrain(integral, -1000, 1000); // Anti-windup float I = KI * integral; float derivative = (error - lastError) / dt; float D = KD * derivative; float motor_speed_delta = P + I + D; The integral term includes anti-windup clamping to prevent it from accumulating too much error when the robot is off the line for extended periods. We also reset the PID state (error, integral, and timing) whenever transitioning between states to prevent any weird behavior from stale values.\nShooter Control The shooting mechanism was very simple, just a digital pin that triggers a relay to trigger the motorized lever arm. A quick HIGH pulse for 300ms is all it takes to launch a duck into the pond. I added small delays before and after to ensure clean activation and so that we don\u0026rsquo;t brownout the robot which was an issue we had when trying to run both the wheels and shooter motor at the same time.\nRetrospective Overall we did great and I\u0026rsquo;m very proud of my team for coming first over two thousand freshman engineers! The average score was probably less than 5k which we crushed scoring 30,500 points with 81 ducks (44 in the 500, 24 in the 300, and 13 in the 100).\nVideo of our Final run ","permalink":"http://localhost:1313/posts/duck-launcher/","summary":"How we made the highest scoring duck launcher.","title":"Duck Launcher"},{"content":" Hardware ESP32-C3 Super Mini Force Sensitive Resistor (FSR) 10K ohm Resistor 3D-Printed Case As I often use ESP32-C3 Super Minis in a lot of my projects due to their extremely small size I had already designed a slim case for them which worked prefectly for this application. The case can be found here on my MakerWorld Profile Page.\nWiring The wiring was very simple, I just soldered one pin of the FSR to 3.3v and then the other pin to a analog pin, in my case pin 4, with the resistor connecting pin 4 and ground.\nSoftware Using Esphome I wrote a basic yaml code to publish a resistor value as well as a binary occupancy value to HomeAssistant that can be found here.\n","permalink":"http://localhost:1313/posts/bed-occupancy-sensor/","summary":"Low cost bed occupancy sensor made with an esp32-c3 super mini and a $10 resistor.","title":"Bed Occupancy Sensor"},{"content":" I wanted an automated blind solution that wouldn\u0026rsquo;t rely on cloud services or expensive commercial products. By repurposing an IKEA roller shades and designing my own controller system, I was able to build a cheap local solution.\nHardware The smart blind consists of four main components:\n28BYJ-48 stepper motor ULN2003 stepper motor driver board ESP32 microcontroller IKEA roller shade I chose these because they were very cheap off of Amazon or Aliexpress and because the ULN2003 was supported by Esphome\u0026rsquo;s stepper component which I was planning on using to program the esp32.\n3D-Printed Case To mount and house the motor and eletronics I designed a 3d printed case in Fusion360. This was my first time cading gears so it took me a bit to get the correct gear ration that would allow the motor to have enough torque to raise the blinds without skipping. After that it was just a matter of blocking out where each component would go and build the case around them.\nWiring The wiring for the ULN2003 was rather straight forward and only needed 4 wires connected to the esp32 and then power and ground for both the driver and esp32\nSoftware To test that everything was working I wrote a quick arduino program to spin the motor in both directions for a few seconds. After confirming my wiring was correct and the code ran I started to write the Esphome code. During this process, I discovered that RoadKillUK had published a Github that was very similar to what I was trying to accomplish. I only had to modify the code slightly to work with an esp32 but it was pretty much perfect.\nUsage \u0026amp; Future Improvements I\u0026rsquo;ve been running the blind for a little over a year now and have had no issue with it so far. There are a few things that I would change if I made a second version. First, the blinds are slow, they take over a minuet to raise/lower about 3 feet. Second, the stepper motor loses its memory of the blind position if it loses power and will need to be re-homed.\n","permalink":"http://localhost:1313/posts/smart-blinds-v1/","summary":"Cheap, simple and effective smart blinds made from and old IKEA roller shades and a few electronic components.","title":"Smart Blinds"},{"content":"I’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\nMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003eI’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\u003c/p\u003e\n\u003cp\u003eMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\u003c/p\u003e","title":"About"},{"content":" Duck Launcher Final At UCF every freshman engineering student is split into groups of four and tasked with designing and programming a TI-RSLK robot to score as many little rubber ducks in the \u0026ldquo;pond\u0026rdquo; as fast as possible by following a black line to the pond within 10 minutes.\nThe pond is a large pentagon in the middle of 5 tracks that teams are trying to score into. There are 3 zones in the pond, each getting progressively smaller and worth more points; 100, 300, and 500 respectively. There are also penalty cups closest to the black line that add a time penalty if hit, and bonus cups at the start line that can be hit on the way back for a 50 point bonus every time.\nDesign Our main design goal was to score in the 500 point section as quickly as possible. We really wanted to get cycle times to be as quick as possible since we were worried about the small size of the center 500 point ring filling up and preventing us from scoring all the points possible. Some constraints we had to follow were that the robot must be against the pond wall before shooting a duck and the motors on the robot were rather weak, making it essential we keep the weight of our mechanisms to a minimum.\nAfter testing out several design archetypes we settled on a motorized lever arm. This allowed us to quickly shoot ducks as soon as we hit the wall of the pond and was overall a very lightweight and compact mechanism. We ended up going through seven versions, tweaking various gear ratios and arm lengths before we finally settled on the model we used. Here is the link to the CAD for anyone interested: CAD Model - Onshape\nProgramming Every group was provided with very basic but working example code. However, this code was very messy and extremely slow which caused me to decide to rewrite it from scratch. One of the biggest issues with the example code is that they do not use a full PID, instead they just use a P value. While this works fine for the majority of robots, if you wanted to go faster than about 30% speed a true PID implementation is required.\nState Machine Architecture I structured the program around a state machine with six states: START, RESTART, PATH, SHOOT, TURN, and DONE. This made the code significantly cleaner and easier to debug which I will give credit to the example code for doing partially correct. Each state has its own dedicated function that handles exactly what needs to happen in that phase of the run.\nThe robot starts in START, waiting for a button press. Once triggered, it transitions to PATH where the line following happens. When the bump sensors detect the wall, it moves to SHOOT, fires the duck launcher mechanism, then enters TURN to do a 180-degree spin. After turning, it goes back to PATH to return home. On the second bump which is hitting the robot resetters hand for faster reset times, it transitions to DONE and waits for a restart by pressing the front bumper again.\nFull PID Implementation A proper PID controller is needed to consistently follow the line at faster speeds. The key improvement over the example code was using actual time deltas for the integral and derivative calculations rather than assuming a fixed loop time. We tuned our constants to KP = 0.05, KI = 0.001, and KD = 0.01 which allowed us to run at 90% motor speed while still tracking the line accurately. These values differed per robot as they all were in different states of disrepair so we were never able to tune the PID to be as smooth as I wanted.\nfloat dt = (currentTime - lastPIDTime) / 1000.0; // Convert to seconds int error = linePos - GOAL; float P = KP * error; integral += error * dt; integral = constrain(integral, -1000, 1000); // Anti-windup float I = KI * integral; float derivative = (error - lastError) / dt; float D = KD * derivative; float motor_speed_delta = P + I + D; The integral term includes anti-windup clamping to prevent it from accumulating too much error when the robot is off the line for extended periods. We also reset the PID state (error, integral, and timing) whenever transitioning between states to prevent any weird behavior from stale values.\nShooter Control The shooting mechanism was very simple, just a digital pin that triggers a relay to trigger the motorized lever arm. A quick HIGH pulse for 300ms is all it takes to launch a duck into the pond. I added small delays before and after to ensure clean activation and so that we don\u0026rsquo;t brownout the robot which was an issue we had when trying to run both the wheels and shooter motor at the same time.\nRetrospective Overall we did great and I\u0026rsquo;m very proud of my team for coming first out of over two thousand freshman engineers! The average score was probably less than 2-3k which we crushed scoring 30,500 points with 81 ducks (44 in the 500, 24 in the 300, and 13 in the 100).\nThere were a lot of cool and unique designs that I saw and we learned a lot about what works and what should be avoided. If we were to do this again there are several things we would change.\nFirst off, our fears of the center getting filled were confirmed but not due to other teams but because our cycles were so fast that the center was filled about 2-3 minuets into the competition. This caused a lot of ducks to bounce out of the center off of other ducks and land in the 100 and 300 point section. We had nearly perfect accuracy so all the ducks from the score breakdown in the other sections are due to them bouncing out of the center. The best way to avoid this would probably be to fine tune the launch angle so that it either goes at a more downward angle to bounce up again rather than at an angle or go at a very shallow angle so that the ducks hit the back wall of the 500 point zone and bounce inwards, this is similar to what our launcher did but it could be improved.\nVideo of our Final run ","permalink":"http://localhost:1313/posts/duck-launcher/","summary":"How we made the highest scoring duck launcher.","title":"Duck Launcher"},{"content":" Hardware ESP32-C3 Super Mini Force Sensitive Resistor (FSR) 10K ohm Resistor 3D-Printed Case As I often use ESP32-C3 Super Minis in a lot of my projects due to their extremely small size I had already designed a slim case for them which worked prefectly for this application. The case can be found here on my MakerWorld Profile Page.\nWiring The wiring was very simple, I just soldered one pin of the FSR to 3.3v and then the other pin to a analog pin, in my case pin 4, with the resistor connecting pin 4 and ground.\nSoftware Using Esphome I wrote a basic yaml code to publish a resistor value as well as a binary occupancy value to HomeAssistant that can be found here.\n","permalink":"http://localhost:1313/posts/bed-occupancy-sensor/","summary":"Low cost bed occupancy sensor made with an esp32-c3 super mini and a $10 resistor.","title":"Bed Occupancy Sensor"},{"content":" I wanted an automated blind solution that wouldn\u0026rsquo;t rely on cloud services or expensive commercial products. By repurposing an IKEA roller shades and designing my own controller system, I was able to build a cheap local solution.\nHardware The smart blind consists of four main components:\n28BYJ-48 stepper motor ULN2003 stepper motor driver board ESP32 microcontroller IKEA roller shade I chose these because they were very cheap off of Amazon or Aliexpress and because the ULN2003 was supported by Esphome\u0026rsquo;s stepper component which I was planning on using to program the esp32.\n3D-Printed Case To mount and house the motor and eletronics I designed a 3d printed case in Fusion360. This was my first time cading gears so it took me a bit to get the correct gear ration that would allow the motor to have enough torque to raise the blinds without skipping. After that it was just a matter of blocking out where each component would go and build the case around them.\nWiring The wiring for the ULN2003 was rather straight forward and only needed 4 wires connected to the esp32 and then power and ground for both the driver and esp32\nSoftware To test that everything was working I wrote a quick arduino program to spin the motor in both directions for a few seconds. After confirming my wiring was correct and the code ran I started to write the Esphome code. During this process, I discovered that RoadKillUK had published a Github that was very similar to what I was trying to accomplish. I only had to modify the code slightly to work with an esp32 but it was pretty much perfect.\nUsage \u0026amp; Future Improvements I\u0026rsquo;ve been running the blind for a little over a year now and have had no issue with it so far. There are a few things that I would change if I made a second version. First, the blinds are slow, they take over a minuet to raise/lower about 3 feet. Second, the stepper motor loses its memory of the blind position if it loses power and will need to be re-homed.\n","permalink":"http://localhost:1313/posts/smart-blinds-v1/","summary":"Cheap, simple and effective smart blinds made from and old IKEA roller shades and a few electronic components.","title":"Smart Blinds"},{"content":"I’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\nMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003eI’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\u003c/p\u003e\n\u003cp\u003eMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\u003c/p\u003e","title":"About"},{"content":" Duck Launcher Final At UCF every freshman engineering student is split into groups of four and tasked with designing and programming a TI-RSLK robot to score as many little rubber ducks in the \u0026ldquo;pond\u0026rdquo; as fast as possible by following a black line to the pond within 10 minutes.\nThe pond is a large pentagon in the middle of 5 tracks that teams are trying to score into. There are 3 zones in the pond, each getting progressively smaller and worth more points; 100, 300, and 500 respectively. There are also penalty cups closest to the black line that add a time penalty if hit, and bonus cups at the start line that can be hit on the way back for a 50 point bonus every time.\nDesign Our main design goal was to score in the 500 point section as quickly as possible. We really wanted to get cycle times to be as quick as possible since we were worried about the small size of the center 500 point ring filling up and preventing us from scoring all the points possible. Some constraints we had to follow were that the robot must be against the pond wall before shooting a duck and the motors on the robot were rather weak, making it essential we keep the weight of our mechanisms to a minimum. We also needed to hit the wall perfectly perpendicular to make aiming more accurate.\nAfter testing out several design archetypes we settled on a motorized lever arm. This allowed us to quickly shoot ducks as soon as we hit the wall of the pond and was overall a very lightweight and compact mechanism. To fix the aiming issue we added a front bumper that went over the front two bump switches that forced the robot to go flat against the wall. We ended up going through seven versions, tweaking various gear ratios and arm lengths before we finally settled on the model we used. Here is the link to the CAD for anyone interested: CAD Model - Onshape\nProgramming Every group was provided with very basic but working example code. However, this code was very messy and extremely slow which caused me to decide to rewrite it from scratch. One of the biggest issues with the example code is that they do not use a full PID, instead they just use a P value. While this works fine for the majority of robots, if you wanted to go faster than about 30% speed a true PID implementation is required.\nState Machine Architecture I structured the program around a state machine with six states: START, RESTART, PATH, SHOOT, TURN, and DONE. This made the code significantly cleaner and easier to debug which I will give credit to the example code for doing partially correct. Each state has its own dedicated function that handles exactly what needs to happen in that phase of the run.\nThe robot starts in START, waiting for a button press. Once triggered, it transitions to PATH where the line following happens. When the bump sensors detect the wall, it moves to SHOOT, fires the duck launcher mechanism, then enters TURN to do a 180-degree spin. After turning, it goes back to PATH to return home. On the second bump which is hitting the robot resetters hand for faster reset times, it transitions to DONE and waits for a restart by pressing the front bumper again.\nFull PID Implementation A proper PID controller is needed to consistently follow the line at faster speeds. The key improvement over the example code was using actual time deltas for the integral and derivative calculations rather than assuming a fixed loop time. We tuned our constants to KP = 0.05, KI = 0.001, and KD = 0.01 which allowed us to run at 90% motor speed while still tracking the line accurately. These values differed per robot as they all were in different states of disrepair so we were never able to tune the PID to be as smooth as I wanted.\nfloat dt = (currentTime - lastPIDTime) / 1000.0; // Convert to seconds int error = linePos - GOAL; float P = KP * error; integral += error * dt; integral = constrain(integral, -1000, 1000); // Anti-windup float I = KI * integral; float derivative = (error - lastError) / dt; float D = KD * derivative; float motor_speed_delta = P + I + D; The integral term includes anti-windup clamping to prevent it from accumulating too much error when the robot is off the line for extended periods. We also reset the PID state (error, integral, and timing) whenever transitioning between states to prevent any weird behavior from stale values.\nShooter Control The shooting mechanism was very simple, just a digital pin that triggers a relay to trigger the motorized lever arm. A quick HIGH pulse for 300ms is all it takes to launch a duck into the pond. I added small delays before and after to ensure clean activation and so that we don\u0026rsquo;t brownout the robot which was an issue we had when trying to run both the wheels and shooter motor at the same time.\nRetrospective Overall we did great and I\u0026rsquo;m very proud of my team for coming first out of over two thousand freshman engineers! The average score was probably less than 2-3k which we crushed, scoring 30,500 points with 81 ducks (44 in the 500, 24 in the 300, and 13 in the 100).\nThere were a lot of cool and unique designs that I saw and we learned a lot about what works and what should be avoided. If we were to do this again there are several things we would change.\nFirst off, our fears of the center getting filled were confirmed, but not due to other teams—our cycles were so fast that the center was filled about 2-3 minutes into the competition. This caused a lot of ducks to bounce out of the center off of other ducks and land in the 100 and 300 point sections. We had nearly perfect accuracy so all the ducks from the score breakdown in the other sections are due to them bouncing out of the center. The best way to avoid this would probably be to fine tune the launch angle so that it either goes at a more downward angle to bounce up again or go at a very shallow angle so that the ducks hit the back wall of the 500 point zone and bounce inwards. This is similar to what our launcher did but it could be improved. Another way could be instead of launching the ducks, have a way to drop or place them in the center which would prevent them from bouncing out and make it so they can be stacked higher before completely filling it up.\nSecond, the PID tuning process could be improved. Ideally the PID should be tuned on a straight line at the weight of the final robot, and even better with the robot that is going to be used during the competition. Realistically the latter isn\u0026rsquo;t possible but the first two are very achievable and I am annoyed I didn\u0026rsquo;t think to just bring electrical tape to the lab and make a straight line for tuning.\nThe last thing is the line sensor is so close to the wheels that the PID needs to have higher than normal values to compensate for the short response time that\u0026rsquo;s needed. This isn\u0026rsquo;t as essential since we were able to run at 90% speed and most likely could have gotten that higher with more time spent tuning, but if it\u0026rsquo;s possible to move the line sensor forwards then do so.\nA fun bonus tip is to 3D print or buy a second wheel for the robot as they normally only had one and it makes it significantly more stable and accurate.\nVideo of our Final run ","permalink":"http://localhost:1313/posts/duck-launcher/","summary":"How we made the highest scoring duck launcher.","title":"Duck Launcher"},{"content":" Hardware ESP32-C3 Super Mini Force Sensitive Resistor (FSR) 10K ohm Resistor 3D-Printed Case As I often use ESP32-C3 Super Minis in a lot of my projects due to their extremely small size I had already designed a slim case for them which worked prefectly for this application. The case can be found here on my MakerWorld Profile Page.\nWiring The wiring was very simple, I just soldered one pin of the FSR to 3.3v and then the other pin to a analog pin, in my case pin 4, with the resistor connecting pin 4 and ground.\nSoftware Using Esphome I wrote a basic yaml code to publish a resistor value as well as a binary occupancy value to HomeAssistant that can be found here.\n","permalink":"http://localhost:1313/posts/bed-occupancy-sensor/","summary":"Low cost bed occupancy sensor made with an esp32-c3 super mini and a $10 resistor.","title":"Bed Occupancy Sensor"},{"content":" I wanted an automated blind solution that wouldn\u0026rsquo;t rely on cloud services or expensive commercial products. By repurposing an IKEA roller shades and designing my own controller system, I was able to build a cheap local solution.\nHardware The smart blind consists of four main components:\n28BYJ-48 stepper motor ULN2003 stepper motor driver board ESP32 microcontroller IKEA roller shade I chose these because they were very cheap off of Amazon or Aliexpress and because the ULN2003 was supported by Esphome\u0026rsquo;s stepper component which I was planning on using to program the esp32.\n3D-Printed Case To mount and house the motor and eletronics I designed a 3d printed case in Fusion360. This was my first time cading gears so it took me a bit to get the correct gear ration that would allow the motor to have enough torque to raise the blinds without skipping. After that it was just a matter of blocking out where each component would go and build the case around them.\nWiring The wiring for the ULN2003 was rather straight forward and only needed 4 wires connected to the esp32 and then power and ground for both the driver and esp32\nSoftware To test that everything was working I wrote a quick arduino program to spin the motor in both directions for a few seconds. After confirming my wiring was correct and the code ran I started to write the Esphome code. During this process, I discovered that RoadKillUK had published a Github that was very similar to what I was trying to accomplish. I only had to modify the code slightly to work with an esp32 but it was pretty much perfect.\nUsage \u0026amp; Future Improvements I\u0026rsquo;ve been running the blind for a little over a year now and have had no issue with it so far. There are a few things that I would change if I made a second version. First, the blinds are slow, they take over a minuet to raise/lower about 3 feet. Second, the stepper motor loses its memory of the blind position if it loses power and will need to be re-homed.\n","permalink":"http://localhost:1313/posts/smart-blinds-v1/","summary":"Cheap, simple and effective smart blinds made from and old IKEA roller shades and a few electronic components.","title":"Smart Blinds"},{"content":"I’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\nMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003eI’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\u003c/p\u003e\n\u003cp\u003eMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\u003c/p\u003e","title":"About"},{"content":" Duck Launcher Final At UCF every freshman engineering student is split into groups of four and tasked with designing and programming a TI-RSLK robot to score as many little rubber ducks in the \u0026ldquo;pond\u0026rdquo; as fast as possible by following a black line to the pond within 10 minutes.\nThe pond is a large pentagon in the middle of 5 tracks that teams are trying to score into. There are 3 zones in the pond, each getting progressively smaller and worth more points; 100, 300, and 500 respectively. There are also penalty cups closest to the black line that add a time penalty if hit, and bonus cups at the start line that can be hit on the way back for a 50 point bonus every time.\nDesign Our main design goal was to score in the 500 point section as quickly as possible. We really wanted to get cycle times to be as quick as possible since we were worried about the small size of the center 500 point ring filling up and preventing us from scoring all the points possible. Some constraints we had to follow were that the robot must be against the pond wall before shooting a duck and the motors on the robot were rather weak, making it essential we keep the weight of our mechanisms to a minimum. We also needed to hit the wall perfectly perpendicular to make aiming more accurate.\nAfter testing out several design archetypes we settled on a motorized lever arm. This allowed us to quickly shoot ducks as soon as we hit the wall of the pond and was overall a very lightweight and compact mechanism. To fix the aiming issue we added a front bumper that went over the front two bump switches that forced the robot to go flat against the wall. We ended up going through seven versions, tweaking various gear ratios and arm lengths before we finally settled on the model we used. Here is the link to the CAD for anyone interested: CAD Model - Onshape\nProgramming Every group was provided with very basic but working example code. However, this code was very messy and extremely slow which caused me to decide to rewrite it from scratch. One of the biggest issues with the example code is that they do not use a full PID, instead they just use a P value. While this works fine for the majority of robots, if you wanted to go faster than about 30% speed a true PID implementation is required.\nState Machine Architecture I structured the program around a state machine with six states: START, RESTART, PATH, SHOOT, TURN, and DONE. This made the code significantly cleaner and easier to debug which I will give credit to the example code for doing partially correct. Each state has its own dedicated function that handles exactly what needs to happen in that phase of the run.\nThe robot starts in START, waiting for a button press. Once triggered, it transitions to PATH where the line following happens. When the bump sensors detect the wall, it moves to SHOOT, fires the duck launcher mechanism, then enters TURN to do a 180-degree spin. After turning, it goes back to PATH to return home. On the second bump which is hitting the robot resetters hand for faster reset times, it transitions to DONE and waits for a restart by pressing the front bumper again.\nFull PID Implementation A proper PID controller is needed to consistently follow the line at faster speeds. The key improvement over the example code was using actual time deltas for the integral and derivative calculations rather than assuming a fixed loop time. We tuned our constants to KP = 0.05, KI = 0.001, and KD = 0.01 which allowed us to run at 90% motor speed while still tracking the line accurately. These values differed per robot as they all were in different states of disrepair so we were never able to tune the PID to be as smooth as I wanted.\nfloat dt = (currentTime - lastPIDTime) / 1000.0; // Convert to seconds int error = linePos - GOAL; float P = KP * error; integral += error * dt; integral = constrain(integral, -1000, 1000); // Anti-windup float I = KI * integral; float derivative = (error - lastError) / dt; float D = KD * derivative; float motor_speed_delta = P + I + D; The integral term includes anti-windup clamping to prevent it from accumulating too much error when the robot is off the line for extended periods. We also reset the PID state (error, integral, and timing) whenever transitioning between states to prevent any weird behavior from stale values.\nShooter Control The shooting mechanism was very simple, just a digital pin that triggers a relay to trigger the motorized lever arm. A quick HIGH pulse for 300ms is all it takes to launch a duck into the pond. I added small delays before and after to ensure clean activation and so that we don\u0026rsquo;t brownout the robot which was an issue we had when trying to run both the wheels and shooter motor at the same time.\nThe full code can be view here on my github: (DuckLaucher)[https://github.com/PureRandomGit/DuckLaucher] Its not very pretty as a good bit of it was redone the day of the competition for a slight optimization in the PID. There is also a very basic score keeping webpage, its only slightly broken.\nRetrospective Overall we did great and I\u0026rsquo;m very proud of my team for coming first out of over two thousand freshman engineers! The average score was probably less than 2-3k which we crushed, scoring 30,500 points with 81 ducks (44 in the 500, 24 in the 300, and 13 in the 100).\nThere were a lot of cool and unique designs that I saw and we learned a lot about what works and what should be avoided. If we were to do this again there are several things we would change.\nFirst off, our fears of the center getting filled were confirmed, but not due to other teams—our cycles were so fast that the center was filled about 2-3 minutes into the competition. This caused a lot of ducks to bounce out of the center off of other ducks and land in the 100 and 300 point sections. We had nearly perfect accuracy so all the ducks from the score breakdown in the other sections are due to them bouncing out of the center. The best way to avoid this would probably be to fine tune the launch angle so that it either goes at a more downward angle to bounce up again or go at a very shallow angle so that the ducks hit the back wall of the 500 point zone and bounce inwards. This is similar to what our launcher did but it could be improved. Another way could be instead of launching the ducks, have a way to drop or place them in the center which would prevent them from bouncing out and make it so they can be stacked higher before completely filling it up.\nSecond, the PID tuning process could be improved. Ideally the PID should be tuned on a straight line at the weight of the final robot, and even better with the robot that is going to be used during the competition. Realistically the latter isn\u0026rsquo;t possible but the first two are very achievable and I am annoyed I didn\u0026rsquo;t think to just bring electrical tape to the lab and make a straight line for tuning.\nThe last thing is the line sensor is so close to the wheels that the PID needs to have higher than normal values to compensate for the short response time that\u0026rsquo;s needed. This isn\u0026rsquo;t as essential since we were able to run at 90% speed and most likely could have gotten that higher with more time spent tuning, but if it\u0026rsquo;s possible to move the line sensor forwards then do so.\nA fun bonus tip is to 3D print or buy a second wheel for the robot as they normally only had one and it makes it significantly more stable and accurate.\nVideo of our Final run ","permalink":"http://localhost:1313/posts/duck-launcher/","summary":"How we made the highest scoring duck launcher.","title":"Duck Launcher"},{"content":" Hardware ESP32-C3 Super Mini Force Sensitive Resistor (FSR) 10K ohm Resistor 3D-Printed Case As I often use ESP32-C3 Super Minis in a lot of my projects due to their extremely small size I had already designed a slim case for them which worked prefectly for this application. The case can be found here on my MakerWorld Profile Page.\nWiring The wiring was very simple, I just soldered one pin of the FSR to 3.3v and then the other pin to a analog pin, in my case pin 4, with the resistor connecting pin 4 and ground.\nSoftware Using Esphome I wrote a basic yaml code to publish a resistor value as well as a binary occupancy value to HomeAssistant that can be found here.\n","permalink":"http://localhost:1313/posts/bed-occupancy-sensor/","summary":"Low cost bed occupancy sensor made with an esp32-c3 super mini and a $10 resistor.","title":"Bed Occupancy Sensor"},{"content":" I wanted an automated blind solution that wouldn\u0026rsquo;t rely on cloud services or expensive commercial products. By repurposing an IKEA roller shades and designing my own controller system, I was able to build a cheap local solution.\nHardware The smart blind consists of four main components:\n28BYJ-48 stepper motor ULN2003 stepper motor driver board ESP32 microcontroller IKEA roller shade I chose these because they were very cheap off of Amazon or Aliexpress and because the ULN2003 was supported by Esphome\u0026rsquo;s stepper component which I was planning on using to program the esp32.\n3D-Printed Case To mount and house the motor and eletronics I designed a 3d printed case in Fusion360. This was my first time cading gears so it took me a bit to get the correct gear ration that would allow the motor to have enough torque to raise the blinds without skipping. After that it was just a matter of blocking out where each component would go and build the case around them.\nWiring The wiring for the ULN2003 was rather straight forward and only needed 4 wires connected to the esp32 and then power and ground for both the driver and esp32\nSoftware To test that everything was working I wrote a quick arduino program to spin the motor in both directions for a few seconds. After confirming my wiring was correct and the code ran I started to write the Esphome code. During this process, I discovered that RoadKillUK had published a Github that was very similar to what I was trying to accomplish. I only had to modify the code slightly to work with an esp32 but it was pretty much perfect.\nUsage \u0026amp; Future Improvements I\u0026rsquo;ve been running the blind for a little over a year now and have had no issue with it so far. There are a few things that I would change if I made a second version. First, the blinds are slow, they take over a minuet to raise/lower about 3 feet. Second, the stepper motor loses its memory of the blind position if it loses power and will need to be re-homed.\n","permalink":"http://localhost:1313/posts/smart-blinds-v1/","summary":"Cheap, simple and effective smart blinds made from and old IKEA roller shades and a few electronic components.","title":"Smart Blinds"},{"content":"I’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\nMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003eI’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\u003c/p\u003e\n\u003cp\u003eMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\u003c/p\u003e","title":"About"},{"content":" Duck Launcher Final At UCF every freshman engineering student is split into groups of four and tasked with designing and programming a TI-RSLK robot to score as many little rubber ducks in the \u0026ldquo;pond\u0026rdquo; as fast as possible by following a black line to the pond within 10 minutes.\nThe pond is a large pentagon in the middle of 5 tracks that teams are trying to score into. There are 3 zones in the pond, each getting progressively smaller and worth more points; 100, 300, and 500 respectively. There are also penalty cups closest to the black line that add a time penalty if hit, and bonus cups at the start line that can be hit on the way back for a 50 point bonus every time.\nDesign Our main design goal was to score in the 500 point section as quickly as possible. We really wanted to get cycle times to be as quick as possible since we were worried about the small size of the center 500 point ring filling up and preventing us from scoring all the points possible. Some constraints we had to follow were that the robot must be against the pond wall before shooting a duck and the motors on the robot were rather weak, making it essential we keep the weight of our mechanisms to a minimum. We also needed to hit the wall perfectly perpendicular to make aiming more accurate.\nAfter testing out several design archetypes we settled on a motorized lever arm. This allowed us to quickly shoot ducks as soon as we hit the wall of the pond and was overall a very lightweight and compact mechanism. To fix the aiming issue we added a front bumper that went over the front two bump switches that forced the robot to go flat against the wall. We ended up going through seven versions, tweaking various gear ratios and arm lengths before we finally settled on the model we used. Here is the link to the CAD for anyone interested: CAD Model - Onshape\nProgramming Every group was provided with very basic but working example code. However, this code was very messy and extremely slow which caused me to decide to rewrite it from scratch. One of the biggest issues with the example code is that they do not use a full PID, instead they just use a P value. While this works fine for the majority of robots, if you wanted to go faster than about 30% speed a true PID implementation is required.\nState Machine Architecture I structured the program around a state machine with six states: START, RESTART, PATH, SHOOT, TURN, and DONE. This made the code significantly cleaner and easier to debug which I will give credit to the example code for doing partially correct. Each state has its own dedicated function that handles exactly what needs to happen in that phase of the run.\nThe robot starts in START, waiting for a button press. Once triggered, it transitions to PATH where the line following happens. When the bump sensors detect the wall, it moves to SHOOT, fires the duck launcher mechanism, then enters TURN to do a 180-degree spin. After turning, it goes back to PATH to return home. On the second bump which is hitting the robot resetters hand for faster reset times, it transitions to DONE and waits for a restart by pressing the front bumper again.\nFull PID Implementation A proper PID controller is needed to consistently follow the line at faster speeds. The key improvement over the example code was using actual time deltas for the integral and derivative calculations rather than assuming a fixed loop time. We tuned our constants to KP = 0.05, KI = 0.001, and KD = 0.01 which allowed us to run at 90% motor speed while still tracking the line accurately. These values differed per robot as they all were in different states of disrepair so we were never able to tune the PID to be as smooth as I wanted.\nfloat dt = (currentTime - lastPIDTime) / 1000.0; // Convert to seconds int error = linePos - GOAL; float P = KP * error; integral += error * dt; integral = constrain(integral, -1000, 1000); // Anti-windup float I = KI * integral; float derivative = (error - lastError) / dt; float D = KD * derivative; float motor_speed_delta = P + I + D; The integral term includes anti-windup clamping to prevent it from accumulating too much error when the robot is off the line for extended periods. We also reset the PID state (error, integral, and timing) whenever transitioning between states to prevent any weird behavior from stale values.\nShooter Control The shooting mechanism was very simple, just a digital pin that triggers a relay to trigger the motorized lever arm. A quick HIGH pulse for 300ms is all it takes to launch a duck into the pond. I added small delays before and after to ensure clean activation and so that we don\u0026rsquo;t brownout the robot which was an issue we had when trying to run both the wheels and shooter motor at the same time.\nThe full code can be view here on my github: DuckLaucher Its not very pretty as a good bit of it was redone the day of the competition for a slight optimization in the PID. There is also a very basic score keeping webpage, its only slightly broken.\nRetrospective Overall we did great and I\u0026rsquo;m very proud of my team for coming first out of over two thousand freshman engineers! The average score was probably less than 2-3k which we crushed, scoring 30,500 points with 81 ducks (44 in the 500, 24 in the 300, and 13 in the 100).\nThere were a lot of cool and unique designs that I saw and we learned a lot about what works and what should be avoided. If we were to do this again there are several things we would change.\nFirst off, our fears of the center getting filled were confirmed, but not due to other teams—our cycles were so fast that the center was filled about 2-3 minutes into the competition. This caused a lot of ducks to bounce out of the center off of other ducks and land in the 100 and 300 point sections. We had nearly perfect accuracy so all the ducks from the score breakdown in the other sections are due to them bouncing out of the center. The best way to avoid this would probably be to fine tune the launch angle so that it either goes at a more downward angle to bounce up again or go at a very shallow angle so that the ducks hit the back wall of the 500 point zone and bounce inwards. This is similar to what our launcher did but it could be improved. Another way could be instead of launching the ducks, have a way to drop or place them in the center which would prevent them from bouncing out and make it so they can be stacked higher before completely filling it up.\nSecond, the PID tuning process could be improved. Ideally the PID should be tuned on a straight line at the weight of the final robot, and even better with the robot that is going to be used during the competition. Realistically the latter isn\u0026rsquo;t possible but the first two are very achievable and I am annoyed I didn\u0026rsquo;t think to just bring electrical tape to the lab and make a straight line for tuning.\nThe last thing is the line sensor is so close to the wheels that the PID needs to have higher than normal values to compensate for the short response time that\u0026rsquo;s needed. This isn\u0026rsquo;t as essential since we were able to run at 90% speed and most likely could have gotten that higher with more time spent tuning, but if it\u0026rsquo;s possible to move the line sensor forwards then do so.\nA fun bonus tip is to 3D print or buy a second wheel for the robot as they normally only had one and it makes it significantly more stable and accurate.\nVideo of our Final run ","permalink":"http://localhost:1313/posts/duck-launcher/","summary":"How we made the highest scoring duck launcher.","title":"Duck Launcher"},{"content":" Hardware ESP32-C3 Super Mini Force Sensitive Resistor (FSR) 10K ohm Resistor 3D-Printed Case As I often use ESP32-C3 Super Minis in a lot of my projects due to their extremely small size I had already designed a slim case for them which worked prefectly for this application. The case can be found here on my MakerWorld Profile Page.\nWiring The wiring was very simple, I just soldered one pin of the FSR to 3.3v and then the other pin to a analog pin, in my case pin 4, with the resistor connecting pin 4 and ground.\nSoftware Using Esphome I wrote a basic yaml code to publish a resistor value as well as a binary occupancy value to HomeAssistant that can be found here.\n","permalink":"http://localhost:1313/posts/bed-occupancy-sensor/","summary":"Low cost bed occupancy sensor made with an esp32-c3 super mini and a $10 resistor.","title":"Bed Occupancy Sensor"},{"content":" I wanted an automated blind solution that wouldn\u0026rsquo;t rely on cloud services or expensive commercial products. By repurposing an IKEA roller shades and designing my own controller system, I was able to build a cheap local solution.\nHardware The smart blind consists of four main components:\n28BYJ-48 stepper motor ULN2003 stepper motor driver board ESP32 microcontroller IKEA roller shade I chose these because they were very cheap off of Amazon or Aliexpress and because the ULN2003 was supported by Esphome\u0026rsquo;s stepper component which I was planning on using to program the esp32.\n3D-Printed Case To mount and house the motor and eletronics I designed a 3d printed case in Fusion360. This was my first time cading gears so it took me a bit to get the correct gear ration that would allow the motor to have enough torque to raise the blinds without skipping. After that it was just a matter of blocking out where each component would go and build the case around them.\nWiring The wiring for the ULN2003 was rather straight forward and only needed 4 wires connected to the esp32 and then power and ground for both the driver and esp32\nSoftware To test that everything was working I wrote a quick arduino program to spin the motor in both directions for a few seconds. After confirming my wiring was correct and the code ran I started to write the Esphome code. During this process, I discovered that RoadKillUK had published a Github that was very similar to what I was trying to accomplish. I only had to modify the code slightly to work with an esp32 but it was pretty much perfect.\nUsage \u0026amp; Future Improvements I\u0026rsquo;ve been running the blind for a little over a year now and have had no issue with it so far. There are a few things that I would change if I made a second version. First, the blinds are slow, they take over a minuet to raise/lower about 3 feet. Second, the stepper motor loses its memory of the blind position if it loses power and will need to be re-homed.\n","permalink":"http://localhost:1313/posts/smart-blinds-v1/","summary":"Cheap, simple and effective smart blinds made from and old IKEA roller shades and a few electronic components.","title":"Smart Blinds"},{"content":"I’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\nMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003eI’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\u003c/p\u003e\n\u003cp\u003eMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\u003c/p\u003e","title":"About"},{"content":" Duck Launcher Final At UCF every freshman engineering student is split into groups of four and tasked with designing and programming a TI-RSLK robot to score as many little rubber ducks in the \u0026ldquo;pond\u0026rdquo; as fast as possible by following a black line to the pond within 10 minutes.\nThe pond is a large pentagon in the middle of 5 tracks that teams are trying to score into. There are 3 zones in the pond, each getting progressively smaller and worth more points; 100, 300, and 500 respectively. There are also penalty cups closest to the black line that add a time penalty if hit, and bonus cups at the start line that can be hit on the way back for a 50 point bonus every time.\nDesign Our main design goal was to score in the 500 point section as quickly as possible. We really wanted to get cycle times to be as quick as possible since we were worried about the small size of the center 500 point ring filling up and preventing us from scoring all the points possible. Some constraints we had to follow were that the robot must be against the pond wall before shooting a duck and the motors on the robot were rather weak, making it essential we keep the weight of our mechanisms to a minimum. We also needed to hit the wall perfectly perpendicular to make aiming more accurate.\nAfter testing out several design archetypes we settled on a motorized lever arm. This allowed us to quickly shoot ducks as soon as we hit the wall of the pond and was overall a very lightweight and compact mechanism. To fix the aiming issue we added a front bumper that went over the front two bump switches that forced the robot to go flat against the wall. We ended up going through seven versions, tweaking various gear ratios and arm lengths before we finally settled on the model we used. Here is the link to the CAD for anyone interested: CAD Model - Onshape\nProgramming Every group was provided with very basic but working example code. However, this code was very messy and extremely slow which caused me to decide to rewrite it from scratch. One of the biggest issues with the example code is that they do not use a full PID, instead they just use a P value. While this works fine for the majority of robots, if you wanted to go faster than about 30% speed a true PID implementation is required.\nState Machine Architecture I structured the program around a state machine with six states: START, RESTART, PATH, SHOOT, TURN, and DONE. This made the code significantly cleaner and easier to debug which I will give credit to the example code for doing partially correct. Each state has its own dedicated function that handles exactly what needs to happen in that phase of the run.\nThe robot starts in START, waiting for a button press. Once triggered, it transitions to PATH where the line following happens. When the bump sensors detect the wall, it moves to SHOOT, fires the duck launcher mechanism, then enters TURN to do a 180-degree spin. After turning, it goes back to PATH to return home. On the second bump which is hitting the robot resetters hand for faster reset times, it transitions to DONE and waits for a restart by pressing the front bumper again.\nFull PID Implementation A proper PID controller is needed to consistently follow the line at faster speeds. The key improvement over the example code was using actual time deltas for the integral and derivative calculations rather than assuming a fixed loop time. We tuned our constants to KP = 0.05, KI = 0.001, and KD = 0.01 which allowed us to run at 90% motor speed while still tracking the line accurately. These values differed per robot as they all were in different states of disrepair so we were never able to tune the PID to be as smooth as I wanted.\nfloat dt = (currentTime - lastPIDTime) / 1000.0; // Convert to seconds int error = linePos - GOAL; float P = KP * error; integral += error * dt; integral = constrain(integral, -1000, 1000); // Anti-windup float I = KI * integral; float derivative = (error - lastError) / dt; float D = KD * derivative; float motor_speed_delta = P + I + D; The integral term includes anti-windup clamping to prevent it from accumulating too much error when the robot is off the line for extended periods. We also reset the PID state (error, integral, and timing) whenever transitioning between states to prevent any weird behavior from stale values.\nShooter Control The shooting mechanism was very simple, just a digital pin that triggers a relay to trigger the motorized lever arm. A quick HIGH pulse for 300ms is all it takes to launch a duck into the pond. I added small delays before and after to ensure clean activation and so that we don\u0026rsquo;t brownout the robot which was an issue we had when trying to run both the wheels and shooter motor at the same time.\nThe full code can be view here on my github: DuckLaucher\nIts not very pretty as a good bit of it was redone the day of the competition for a slight optimization in the PID. There is also a very basic score keeping webpage, its only slightly broken.\nRetrospective Overall we did great and I\u0026rsquo;m very proud of my team for coming first out of over two thousand freshman engineers! The average score was probably less than 2-3k which we crushed, scoring 30,500 points with 81 ducks (44 in the 500, 24 in the 300, and 13 in the 100).\nThere were a lot of cool and unique designs that I saw and we learned a lot about what works and what should be avoided. If we were to do this again there are several things we would change.\nFirst off, our fears of the center getting filled were confirmed, but not due to other teams—our cycles were so fast that the center was filled about 2-3 minutes into the competition. This caused a lot of ducks to bounce out of the center off of other ducks and land in the 100 and 300 point sections. We had nearly perfect accuracy so all the ducks from the score breakdown in the other sections are due to them bouncing out of the center. The best way to avoid this would probably be to fine tune the launch angle so that it either goes at a more downward angle to bounce up again or go at a very shallow angle so that the ducks hit the back wall of the 500 point zone and bounce inwards. This is similar to what our launcher did but it could be improved. Another way could be instead of launching the ducks, have a way to drop or place them in the center which would prevent them from bouncing out and make it so they can be stacked higher before completely filling it up.\nSecond, the PID tuning process could be improved. Ideally the PID should be tuned on a straight line at the weight of the final robot, and even better with the robot that is going to be used during the competition. Realistically the latter isn\u0026rsquo;t possible but the first two are very achievable and I am annoyed I didn\u0026rsquo;t think to just bring electrical tape to the lab and make a straight line for tuning.\nThe last thing is the line sensor is so close to the wheels that the PID needs to have higher than normal values to compensate for the short response time that\u0026rsquo;s needed. This isn\u0026rsquo;t as essential since we were able to run at 90% speed and most likely could have gotten that higher with more time spent tuning, but if it\u0026rsquo;s possible to move the line sensor forwards then do so.\nA fun bonus tip is to 3D print or buy a second wheel for the robot as they normally only had one and it makes it significantly more stable and accurate.\nVideo of our Final run ","permalink":"http://localhost:1313/posts/duck-launcher/","summary":"How we made the highest scoring duck launcher.","title":"Duck Launcher"},{"content":" Hardware ESP32-C3 Super Mini Force Sensitive Resistor (FSR) 10K ohm Resistor 3D-Printed Case As I often use ESP32-C3 Super Minis in a lot of my projects due to their extremely small size I had already designed a slim case for them which worked prefectly for this application. The case can be found here on my MakerWorld Profile Page.\nWiring The wiring was very simple, I just soldered one pin of the FSR to 3.3v and then the other pin to a analog pin, in my case pin 4, with the resistor connecting pin 4 and ground.\nSoftware Using Esphome I wrote a basic yaml code to publish a resistor value as well as a binary occupancy value to HomeAssistant that can be found here.\n","permalink":"http://localhost:1313/posts/bed-occupancy-sensor/","summary":"Low cost bed occupancy sensor made with an esp32-c3 super mini and a $10 resistor.","title":"Bed Occupancy Sensor"},{"content":" I wanted an automated blind solution that wouldn\u0026rsquo;t rely on cloud services or expensive commercial products. By repurposing an IKEA roller shades and designing my own controller system, I was able to build a cheap local solution.\nHardware The smart blind consists of four main components:\n28BYJ-48 stepper motor ULN2003 stepper motor driver board ESP32 microcontroller IKEA roller shade I chose these because they were very cheap off of Amazon or Aliexpress and because the ULN2003 was supported by Esphome\u0026rsquo;s stepper component which I was planning on using to program the esp32.\n3D-Printed Case To mount and house the motor and eletronics I designed a 3d printed case in Fusion360. This was my first time cading gears so it took me a bit to get the correct gear ration that would allow the motor to have enough torque to raise the blinds without skipping. After that it was just a matter of blocking out where each component would go and build the case around them.\nWiring The wiring for the ULN2003 was rather straight forward and only needed 4 wires connected to the esp32 and then power and ground for both the driver and esp32\nSoftware To test that everything was working I wrote a quick arduino program to spin the motor in both directions for a few seconds. After confirming my wiring was correct and the code ran I started to write the Esphome code. During this process, I discovered that RoadKillUK had published a Github that was very similar to what I was trying to accomplish. I only had to modify the code slightly to work with an esp32 but it was pretty much perfect.\nUsage \u0026amp; Future Improvements I\u0026rsquo;ve been running the blind for a little over a year now and have had no issue with it so far. There are a few things that I would change if I made a second version. First, the blinds are slow, they take over a minuet to raise/lower about 3 feet. Second, the stepper motor loses its memory of the blind position if it loses power and will need to be re-homed.\n","permalink":"http://localhost:1313/posts/smart-blinds-v1/","summary":"Cheap, simple and effective smart blinds made from and old IKEA roller shades and a few electronic components.","title":"Smart Blinds"},{"content":"I’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\nMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003eI’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\u003c/p\u003e\n\u003cp\u003eMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\u003c/p\u003e","title":"About"},{"content":" Duck Launcher Final At UCF every freshman engineering student is split into groups of four and tasked with designing and programming a TI-RSLK robot to score as many little rubber ducks in the \u0026ldquo;pond\u0026rdquo; as fast as possible by following a black line to the pond within 10 minutes.\nThe pond is a large pentagon in the middle of 5 tracks that teams are trying to score into. There are 3 zones in the pond, each getting progressively smaller and worth more points; 100, 300, and 500 respectively. There are also penalty cups closest to the black line that add a time penalty if hit, and bonus cups at the start line that can be hit on the way back for a 50 point bonus every time.\nDesign Our main design goal was to score in the 500 point section as quickly as possible. We really wanted to get cycle times to be as quick as possible since we were worried about the small size of the center 500 point ring filling up and preventing us from scoring all the points possible. Some constraints we had to follow were that the robot must be against the pond wall before shooting a duck and the motors on the robot were rather weak, making it essential we keep the weight of our mechanisms to a minimum. We also needed to hit the wall perfectly perpendicular to make aiming more accurate.\nAfter testing out several design archetypes we settled on a motorized lever arm. This allowed us to quickly shoot ducks as soon as we hit the wall of the pond and was overall a very lightweight and compact mechanism. To fix the aiming issue we added a front bumper that went over the front two bump switches that forced the robot to go flat against the wall. We ended up going through seven versions, tweaking various gear ratios and arm lengths before we finally settled on the model we used. Here is the link to the CAD for anyone interested: CAD Model - Onshape\nProgramming Every group was provided with very basic but working example code. However, this code was very messy and extremely slow which caused me to decide to rewrite it from scratch. One of the biggest issues with the example code is that they do not use a full PID, instead they just use a P value. While this works fine for the majority of robots, if you wanted to go faster than about 30% speed a true PID implementation is required.\nState Machine Architecture I structured the program around a state machine with six states: START, RESTART, PATH, SHOOT, TURN, and DONE. This made the code significantly cleaner and easier to debug which I will give credit to the example code for doing partially correct. Each state has its own dedicated function that handles exactly what needs to happen in that phase of the run.\nThe robot starts in START, waiting for a button press. Once triggered, it transitions to PATH where the line following happens. When the bump sensors detect the wall, it moves to SHOOT, fires the duck launcher mechanism, then enters TURN to do a 180-degree spin. After turning, it goes back to PATH to return home. On the second bump which is hitting the robot resetters hand for faster reset times, it transitions to DONE and waits for a restart by pressing the front bumper again.\nFull PID Implementation A proper PID controller is needed to consistently follow the line at faster speeds. The key improvement over the example code was using actual time deltas for the integral and derivative calculations rather than assuming a fixed loop time. We tuned our constants to KP = 0.05, KI = 0.001, and KD = 0.01 which allowed us to run at 90% motor speed while still tracking the line accurately. These values differed per robot as they all were in different states of disrepair so we were never able to tune the PID to be as smooth as I wanted.\nfloat dt = (currentTime - lastPIDTime) / 1000.0; // Convert to seconds int error = linePos - GOAL; float P = KP * error; integral += error * dt; integral = constrain(integral, -1000, 1000); // Anti-windup float I = KI * integral; float derivative = (error - lastError) / dt; float D = KD * derivative; float motor_speed_delta = P + I + D; The integral term includes anti-windup clamping to prevent it from accumulating too much error when the robot is off the line for extended periods. We also reset the PID state (error, integral, and timing) whenever transitioning between states to prevent any weird behavior from stale values.\nShooter Control The shooting mechanism was very simple, just a digital pin that triggers a relay to trigger the motorized lever arm. A quick HIGH pulse for 300ms is all it takes to launch a duck into the pond. I added small delays before and after to ensure clean activation and so that we don\u0026rsquo;t brownout the robot which was an issue we had when trying to run both the wheels and shooter motor at the same time.\nThe full code can be view here on my github: DuckLaucher\nIts not very pretty as a good bit of it was redone the day of the competition for a slight optimization in the PID. There is also a very basic score keeping webpage, its only slightly broken.\nRetrospective Overall we did great and I\u0026rsquo;m very proud of my team for coming first out of over two thousand freshman engineers! The average score was probably less than 2-3k which we crushed, scoring 30,500 points with 81 ducks (44 in the 500, 24 in the 300, and 13 in the 100).\nThere were a lot of cool and unique designs that I saw and we learned a lot about what works and what should be avoided. If we were to do this again there are several things we would change.\nFirst off, our fears of the center getting filled were confirmed, but not due to other teams—our cycles were so fast that the center was filled about 2-3 minutes into the competition. This caused a lot of ducks to bounce out of the center off of other ducks and land in the 100 and 300 point sections. We had nearly perfect accuracy so all the ducks from the score breakdown in the other sections are due to them bouncing out of the center. The best way to avoid this would probably be to fine tune the launch angle so that it either goes at a more downward angle to bounce up again or go at a very shallow angle so that the ducks hit the back wall of the 500 point zone and bounce inwards. This is similar to what our launcher did but it could be improved. Another way could be instead of launching the ducks, have a way to drop or place them in the center which would prevent them from bouncing out and make it so they can be stacked higher before completely filling it up.\nSecond, the PID tuning process could be improved. Ideally the PID should be tuned on a straight line at the weight of the final robot, and even better with the robot that is going to be used during the competition. Realistically the latter isn\u0026rsquo;t possible but the first two are very achievable and I am annoyed I didn\u0026rsquo;t think to just bring electrical tape to the lab and make a straight line for tuning.\nThe last thing is the line sensor is so close to the wheels that the PID needs to have higher than normal values to compensate for the short response time that\u0026rsquo;s needed. This isn\u0026rsquo;t as essential since we were able to run at 90% speed and most likely could have gotten that higher with more time spent tuning, but if it\u0026rsquo;s possible to move the line sensor forwards then do so.\nA fun bonus tip is to 3D print or buy a second wheel for the robot as they normally only had one and it makes it significantly more stable and accurate.\nVideo of our competition ","permalink":"http://localhost:1313/posts/duck-launcher/","summary":"How we made the highest scoring duck launcher.","title":"Duck Launcher"},{"content":" Hardware ESP32-C3 Super Mini Force Sensitive Resistor (FSR) 10K ohm Resistor 3D-Printed Case As I often use ESP32-C3 Super Minis in a lot of my projects due to their extremely small size I had already designed a slim case for them which worked prefectly for this application. The case can be found here on my MakerWorld Profile Page.\nWiring The wiring was very simple, I just soldered one pin of the FSR to 3.3v and then the other pin to a analog pin, in my case pin 4, with the resistor connecting pin 4 and ground.\nSoftware Using Esphome I wrote a basic yaml code to publish a resistor value as well as a binary occupancy value to HomeAssistant that can be found here.\n","permalink":"http://localhost:1313/posts/bed-occupancy-sensor/","summary":"Low cost bed occupancy sensor made with an esp32-c3 super mini and a $10 resistor.","title":"Bed Occupancy Sensor"},{"content":" I wanted an automated blind solution that wouldn\u0026rsquo;t rely on cloud services or expensive commercial products. By repurposing an IKEA roller shades and designing my own controller system, I was able to build a cheap local solution.\nHardware The smart blind consists of four main components:\n28BYJ-48 stepper motor ULN2003 stepper motor driver board ESP32 microcontroller IKEA roller shade I chose these because they were very cheap off of Amazon or Aliexpress and because the ULN2003 was supported by Esphome\u0026rsquo;s stepper component which I was planning on using to program the esp32.\n3D-Printed Case To mount and house the motor and eletronics I designed a 3d printed case in Fusion360. This was my first time cading gears so it took me a bit to get the correct gear ration that would allow the motor to have enough torque to raise the blinds without skipping. After that it was just a matter of blocking out where each component would go and build the case around them.\nWiring The wiring for the ULN2003 was rather straight forward and only needed 4 wires connected to the esp32 and then power and ground for both the driver and esp32\nSoftware To test that everything was working I wrote a quick arduino program to spin the motor in both directions for a few seconds. After confirming my wiring was correct and the code ran I started to write the Esphome code. During this process, I discovered that RoadKillUK had published a Github that was very similar to what I was trying to accomplish. I only had to modify the code slightly to work with an esp32 but it was pretty much perfect.\nUsage \u0026amp; Future Improvements I\u0026rsquo;ve been running the blind for a little over a year now and have had no issue with it so far. There are a few things that I would change if I made a second version. First, the blinds are slow, they take over a minuet to raise/lower about 3 feet. Second, the stepper motor loses its memory of the blind position if it loses power and will need to be re-homed.\n","permalink":"http://localhost:1313/posts/smart-blinds-v1/","summary":"Cheap, simple and effective smart blinds made from and old IKEA roller shades and a few electronic components.","title":"Smart Blinds"},{"content":"I’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\nMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003eI’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\u003c/p\u003e\n\u003cp\u003eMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\u003c/p\u003e","title":"About"},{"content":" Duck Launcher Final At UCF every freshman engineering student is split into groups of four and tasked with designing and programming a TI-RSLK robot to score as many little rubber ducks in the \u0026ldquo;pond\u0026rdquo; as fast as possible by following a black line to the pond within 10 minutes.\nThe pond is a large pentagon in the middle of 5 tracks that teams are trying to score into. There are 3 zones in the pond, each getting progressively smaller and worth more points; 100, 300, and 500 respectively. There are also penalty cups closest to the black line that add a time penalty if hit, and bonus cups at the start line that can be hit on the way back for a 50 point bonus every time.\nDesign Our main design goal was to score in the 500 point section as quickly as possible. We really wanted to get cycle times to be as quick as possible since we were worried about the small size of the center 500 point ring filling up and preventing us from scoring all the points possible. Some constraints we had to follow were that the robot must be against the pond wall before shooting a duck and the motors on the robot were rather weak, making it essential we keep the weight of our mechanisms to a minimum. We also needed to hit the wall perfectly perpendicular to make aiming more accurate.\nAfter testing out several design archetypes we settled on a motorized lever arm. This allowed us to quickly shoot ducks as soon as we hit the wall of the pond and was overall a very lightweight and compact mechanism. To fix the aiming issue we added a front bumper that went over the front two bump switches that forced the robot to go flat against the wall. We ended up going through seven versions, tweaking various gear ratios and arm lengths before we finally settled on the model we used. Here is the link to the CAD for anyone interested: CAD Model - Onshape\nProgramming Every group was provided with very basic but working example code. However, this code was very messy and extremely slow which caused me to decide to rewrite it from scratch. One of the biggest issues with the example code is that they do not use a full PID, instead they just use a P value. While this works fine for the majority of robots, if you wanted to go faster than about 30% speed a true PID implementation is required.\nState Machine Architecture I structured the program around a state machine with six states: START, RESTART, PATH, SHOOT, TURN, and DONE. This made the code significantly cleaner and easier to debug which I will give credit to the example code for doing partially correct. Each state has its own dedicated function that handles exactly what needs to happen in that phase of the run.\nThe robot starts in START, waiting for a button press. Once triggered, it transitions to PATH where the line following happens. When the bump sensors detect the wall, it moves to SHOOT, fires the duck launcher mechanism, then enters TURN to do a 180-degree spin. After turning, it goes back to PATH to return home. On the second bump which is hitting the robot resetters hand for faster reset times, it transitions to DONE and waits for a restart by pressing the front bumper again.\nFull PID Implementation A proper PID controller is needed to consistently follow the line at faster speeds. The key improvement over the example code was using actual time deltas for the integral and derivative calculations rather than assuming a fixed loop time. We tuned our constants to KP = 0.05, KI = 0.001, and KD = 0.01 which allowed us to run at 90% motor speed while still tracking the line accurately. These values differed per robot as they all were in different states of disrepair so we were never able to tune the PID to be as smooth as I wanted.\nfloat dt = (currentTime - lastPIDTime) / 1000.0; // Convert to seconds int error = linePos - GOAL; float P = KP * error; integral += error * dt; integral = constrain(integral, -1000, 1000); // Anti-windup float I = KI * integral; float derivative = (error - lastError) / dt; float D = KD * derivative; float motor_speed_delta = P + I + D; The integral term includes anti-windup clamping to prevent it from accumulating too much error when the robot is off the line for extended periods. We also reset the PID state (error, integral, and timing) whenever transitioning between states to prevent any weird behavior from stale values.\nShooter Control The shooting mechanism was very simple, just a digital pin that triggers a relay to trigger the motorized lever arm. A quick HIGH pulse for 300ms is all it takes to launch a duck into the pond. I added small delays before and after to ensure clean activation and so that we don\u0026rsquo;t brownout the robot which was an issue we had when trying to run both the wheels and shooter motor at the same time.\nThe full code can be view here on my github: DuckLaucher\nIts not very pretty as a good bit of it was redone the day of the competition for a slight optimization in the PID. There is also a very basic score keeping webpage, its only slightly broken.\nRetrospective Overall we did great and I\u0026rsquo;m very proud of my team for coming first out of over two thousand freshman engineers! The average score was probably less than 2-3k which we crushed, scoring 30,500 points with 81 ducks (44 in the 500, 24 in the 300, and 13 in the 100).\nThere were a lot of cool and unique designs that I saw and we learned a lot about what works and what should be avoided. If we were to do this again there are several things we would change.\nFirst off, our fears of the center getting filled were confirmed, but not due to other teams—our cycles were so fast that the center was filled about 2-3 minutes into the competition. This caused a lot of ducks to bounce out of the center off of other ducks and land in the 100 and 300 point sections. We had nearly perfect accuracy so all the ducks from the score breakdown in the other sections are due to them bouncing out of the center. The best way to avoid this would probably be to fine tune the launch angle so that it either goes at a more downward angle to bounce up again or go at a very shallow angle so that the ducks hit the back wall of the 500 point zone and bounce inwards. This is similar to what our launcher did but it could be improved. Another way could be instead of launching the ducks, have a way to drop or place them in the center which would prevent them from bouncing out and make it so they can be stacked higher before completely filling it up.\nSecond, the PID tuning process could be improved. Ideally the PID should be tuned on a straight line at the weight of the final robot, and even better with the robot that is going to be used during the competition. Realistically the latter isn\u0026rsquo;t possible but the first two are very achievable and I am annoyed I didn\u0026rsquo;t think to just bring electrical tape to the lab and make a straight line for tuning.\nThe last thing is the line sensor is so close to the wheels that the PID needs to have higher than normal values to compensate for the short response time that\u0026rsquo;s needed. This isn\u0026rsquo;t as essential since we were able to run at 90% speed and most likely could have gotten that higher with more time spent tuning, but if it\u0026rsquo;s possible to move the line sensor forwards then do so.\nA fun bonus tip is to 3D print or buy a second wheel for the robot as they normally only had one and it makes it significantly more stable and accurate.\nVideo of our competition Links\n","permalink":"http://localhost:1313/posts/duck-launcher/","summary":"How we made the highest scoring duck launcher.","title":"Duck Launcher"},{"content":" Hardware ESP32-C3 Super Mini Force Sensitive Resistor (FSR) 10K ohm Resistor 3D-Printed Case As I often use ESP32-C3 Super Minis in a lot of my projects due to their extremely small size I had already designed a slim case for them which worked prefectly for this application. The case can be found here on my MakerWorld Profile Page.\nWiring The wiring was very simple, I just soldered one pin of the FSR to 3.3v and then the other pin to a analog pin, in my case pin 4, with the resistor connecting pin 4 and ground.\nSoftware Using Esphome I wrote a basic yaml code to publish a resistor value as well as a binary occupancy value to HomeAssistant that can be found here.\n","permalink":"http://localhost:1313/posts/bed-occupancy-sensor/","summary":"Low cost bed occupancy sensor made with an esp32-c3 super mini and a $10 resistor.","title":"Bed Occupancy Sensor"},{"content":" I wanted an automated blind solution that wouldn\u0026rsquo;t rely on cloud services or expensive commercial products. By repurposing an IKEA roller shades and designing my own controller system, I was able to build a cheap local solution.\nHardware The smart blind consists of four main components:\n28BYJ-48 stepper motor ULN2003 stepper motor driver board ESP32 microcontroller IKEA roller shade I chose these because they were very cheap off of Amazon or Aliexpress and because the ULN2003 was supported by Esphome\u0026rsquo;s stepper component which I was planning on using to program the esp32.\n3D-Printed Case To mount and house the motor and eletronics I designed a 3d printed case in Fusion360. This was my first time cading gears so it took me a bit to get the correct gear ration that would allow the motor to have enough torque to raise the blinds without skipping. After that it was just a matter of blocking out where each component would go and build the case around them.\nWiring The wiring for the ULN2003 was rather straight forward and only needed 4 wires connected to the esp32 and then power and ground for both the driver and esp32\nSoftware To test that everything was working I wrote a quick arduino program to spin the motor in both directions for a few seconds. After confirming my wiring was correct and the code ran I started to write the Esphome code. During this process, I discovered that RoadKillUK had published a Github that was very similar to what I was trying to accomplish. I only had to modify the code slightly to work with an esp32 but it was pretty much perfect.\nUsage \u0026amp; Future Improvements I\u0026rsquo;ve been running the blind for a little over a year now and have had no issue with it so far. There are a few things that I would change if I made a second version. First, the blinds are slow, they take over a minuet to raise/lower about 3 feet. Second, the stepper motor loses its memory of the blind position if it loses power and will need to be re-homed.\n","permalink":"http://localhost:1313/posts/smart-blinds-v1/","summary":"Cheap, simple and effective smart blinds made from and old IKEA roller shades and a few electronic components.","title":"Smart Blinds"},{"content":"I’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\nMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003eI’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\u003c/p\u003e\n\u003cp\u003eMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\u003c/p\u003e","title":"About"},{"content":" Duck Launcher Final At UCF every freshman engineering student is split into groups of four and tasked with designing and programming a TI-RSLK robot to score as many little rubber ducks in the \u0026ldquo;pond\u0026rdquo; as fast as possible by following a black line to the pond within 10 minutes.\nThe pond is a large pentagon in the middle of 5 tracks that teams are trying to score into. There are 3 zones in the pond, each getting progressively smaller and worth more points; 100, 300, and 500 respectively. There are also penalty cups closest to the black line that add a time penalty if hit, and bonus cups at the start line that can be hit on the way back for a 50 point bonus every time.\nDesign Our main design goal was to score in the 500 point section as quickly as possible. We really wanted to get cycle times to be as quick as possible since we were worried about the small size of the center 500 point ring filling up and preventing us from scoring all the points possible. Some constraints we had to follow were that the robot must be against the pond wall before shooting a duck and the motors on the robot were rather weak, making it essential we keep the weight of our mechanisms to a minimum. We also needed to hit the wall perfectly perpendicular to make aiming more accurate.\nAfter testing out several design archetypes we settled on a motorized lever arm. This allowed us to quickly shoot ducks as soon as we hit the wall of the pond and was overall a very lightweight and compact mechanism. To fix the aiming issue we added a front bumper that went over the front two bump switches that forced the robot to go flat against the wall. We ended up going through seven versions, tweaking various gear ratios and arm lengths before we finally settled on the model we used. Here is the link to the CAD for anyone interested: CAD Model - Onshape\nProgramming Every group was provided with very basic but working example code. However, this code was very messy and extremely slow which caused me to decide to rewrite it from scratch. One of the biggest issues with the example code is that they do not use a full PID, instead they just use a P value. While this works fine for the majority of robots, if you wanted to go faster than about 30% speed a true PID implementation is required.\nState Machine Architecture I structured the program around a state machine with six states: START, RESTART, PATH, SHOOT, TURN, and DONE. This made the code significantly cleaner and easier to debug which I will give credit to the example code for doing partially correct. Each state has its own dedicated function that handles exactly what needs to happen in that phase of the run.\nThe robot starts in START, waiting for a button press. Once triggered, it transitions to PATH where the line following happens. When the bump sensors detect the wall, it moves to SHOOT, fires the duck launcher mechanism, then enters TURN to do a 180-degree spin. After turning, it goes back to PATH to return home. On the second bump which is hitting the robot resetters hand for faster reset times, it transitions to DONE and waits for a restart by pressing the front bumper again.\nFull PID Implementation A proper PID controller is needed to consistently follow the line at faster speeds. The key improvement over the example code was using actual time deltas for the integral and derivative calculations rather than assuming a fixed loop time. We tuned our constants to KP = 0.05, KI = 0.001, and KD = 0.01 which allowed us to run at 90% motor speed while still tracking the line accurately. These values differed per robot as they all were in different states of disrepair so we were never able to tune the PID to be as smooth as I wanted.\nfloat dt = (currentTime - lastPIDTime) / 1000.0; // Convert to seconds int error = linePos - GOAL; float P = KP * error; integral += error * dt; integral = constrain(integral, -1000, 1000); // Anti-windup float I = KI * integral; float derivative = (error - lastError) / dt; float D = KD * derivative; float motor_speed_delta = P + I + D; The integral term includes anti-windup clamping to prevent it from accumulating too much error when the robot is off the line for extended periods. We also reset the PID state (error, integral, and timing) whenever transitioning between states to prevent any weird behavior from stale values.\nShooter Control The shooting mechanism was very simple, just a digital pin that triggers a relay to trigger the motorized lever arm. A quick HIGH pulse for 300ms is all it takes to launch a duck into the pond. I added small delays before and after to ensure clean activation and so that we don\u0026rsquo;t brownout the robot which was an issue we had when trying to run both the wheels and shooter motor at the same time.\nThe full code can be view here on my github: DuckLaucher\nIts not very pretty as a good bit of it was redone the day of the competition for a slight optimization in the PID. There is also a very basic score keeping webpage, its only slightly broken.\nRetrospective Overall we did great and I\u0026rsquo;m very proud of my team for coming first out of over two thousand freshman engineers! The average score was probably less than 2-3k which we crushed, scoring 30,500 points with 81 ducks (44 in the 500, 24 in the 300, and 13 in the 100).\nThere were a lot of cool and unique designs that I saw and we learned a lot about what works and what should be avoided. If we were to do this again there are several things we would change.\nFirst off, our fears of the center getting filled were confirmed, but not due to other teams—our cycles were so fast that the center was filled about 2-3 minutes into the competition. This caused a lot of ducks to bounce out of the center off of other ducks and land in the 100 and 300 point sections. We had nearly perfect accuracy so all the ducks from the score breakdown in the other sections are due to them bouncing out of the center. The best way to avoid this would probably be to fine tune the launch angle so that it either goes at a more downward angle to bounce up again or go at a very shallow angle so that the ducks hit the back wall of the 500 point zone and bounce inwards. This is similar to what our launcher did but it could be improved. Another way could be instead of launching the ducks, have a way to drop or place them in the center which would prevent them from bouncing out and make it so they can be stacked higher before completely filling it up.\nSecond, the PID tuning process could be improved. Ideally the PID should be tuned on a straight line at the weight of the final robot, and even better with the robot that is going to be used during the competition. Realistically the latter isn\u0026rsquo;t possible but the first two are very achievable and I am annoyed I didn\u0026rsquo;t think to just bring electrical tape to the lab and make a straight line for tuning.\nThe last thing is the line sensor is so close to the wheels that the PID needs to have higher than normal values to compensate for the short response time that\u0026rsquo;s needed. This isn\u0026rsquo;t as essential since we were able to run at 90% speed and most likely could have gotten that higher with more time spent tuning, but if it\u0026rsquo;s possible to move the line sensor forwards then do so.\nA fun bonus tip is to 3D print or buy a second wheel for the robot as they normally only had one and it makes it significantly more stable and accurate.\nVideo of our competition Links\n","permalink":"http://localhost:1313/posts/duck-launcher/","summary":"How we made the highest scoring duck launcher.","title":"Duck Launcher"},{"content":" Hardware ESP32-C3 Super Mini Force Sensitive Resistor (FSR) 10K ohm Resistor 3D-Printed Case As I often use ESP32-C3 Super Minis in a lot of my projects due to their extremely small size I had already designed a slim case for them which worked prefectly for this application. The case can be found here on my MakerWorld Profile Page.\nWiring The wiring was very simple, I just soldered one pin of the FSR to 3.3v and then the other pin to a analog pin, in my case pin 4, with the resistor connecting pin 4 and ground.\nSoftware Using Esphome I wrote a basic yaml code to publish a resistor value as well as a binary occupancy value to HomeAssistant that can be found here.\n","permalink":"http://localhost:1313/posts/bed-occupancy-sensor/","summary":"Low cost bed occupancy sensor made with an esp32-c3 super mini and a $10 resistor.","title":"Bed Occupancy Sensor"},{"content":" I wanted an automated blind solution that wouldn\u0026rsquo;t rely on cloud services or expensive commercial products. By repurposing an IKEA roller shades and designing my own controller system, I was able to build a cheap local solution.\nHardware The smart blind consists of four main components:\n28BYJ-48 stepper motor ULN2003 stepper motor driver board ESP32 microcontroller IKEA roller shade I chose these because they were very cheap off of Amazon or Aliexpress and because the ULN2003 was supported by Esphome\u0026rsquo;s stepper component which I was planning on using to program the esp32.\n3D-Printed Case To mount and house the motor and eletronics I designed a 3d printed case in Fusion360. This was my first time cading gears so it took me a bit to get the correct gear ration that would allow the motor to have enough torque to raise the blinds without skipping. After that it was just a matter of blocking out where each component would go and build the case around them.\nWiring The wiring for the ULN2003 was rather straight forward and only needed 4 wires connected to the esp32 and then power and ground for both the driver and esp32\nSoftware To test that everything was working I wrote a quick arduino program to spin the motor in both directions for a few seconds. After confirming my wiring was correct and the code ran I started to write the Esphome code. During this process, I discovered that RoadKillUK had published a Github that was very similar to what I was trying to accomplish. I only had to modify the code slightly to work with an esp32 but it was pretty much perfect.\nUsage \u0026amp; Future Improvements I\u0026rsquo;ve been running the blind for a little over a year now and have had no issue with it so far. There are a few things that I would change if I made a second version. First, the blinds are slow, they take over a minuet to raise/lower about 3 feet. Second, the stepper motor loses its memory of the blind position if it loses power and will need to be re-homed.\n","permalink":"http://localhost:1313/posts/smart-blinds-v1/","summary":"Cheap, simple and effective smart blinds made from and old IKEA roller shades and a few electronic components.","title":"Smart Blinds"},{"content":"I’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\nMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003eI’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\u003c/p\u003e\n\u003cp\u003eMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\u003c/p\u003e","title":"About"},{"content":" Duck Launcher Final At UCF every freshman engineering student is split into groups of four and tasked with designing and programming a TI-RSLK robot to score as many little rubber ducks in the \u0026ldquo;pond\u0026rdquo; as fast as possible by following a black line to the pond within 10 minutes.\nThe pond is a large pentagon in the middle of 5 tracks that teams are trying to score into. There are 3 zones in the pond, each getting progressively smaller and worth more points; 100, 300, and 500 respectively. There are also penalty cups closest to the black line that add a time penalty if hit, and bonus cups at the start line that can be hit on the way back for a 50 point bonus every time.\nDesign Our main design goal was to score in the 500 point section as quickly as possible. We really wanted to get cycle times to be as quick as possible since we were worried about the small size of the center 500 point ring filling up and preventing us from scoring all the points possible. Some constraints we had to follow were that the robot must be against the pond wall before shooting a duck and the motors on the robot were rather weak, making it essential we keep the weight of our mechanisms to a minimum. We also needed to hit the wall perfectly perpendicular to make aiming more accurate.\nAfter testing out several design archetypes we settled on a motorized lever arm. This allowed us to quickly shoot ducks as soon as we hit the wall of the pond and was overall a very lightweight and compact mechanism. To fix the aiming issue we added a front bumper that went over the front two bump switches that forced the robot to go flat against the wall. We ended up going through seven versions, tweaking various gear ratios and arm lengths before we finally settled on the model we used. Here is the link to the CAD for anyone interested: CAD Model - Onshape\nProgramming Every group was provided with very basic but working example code. However, this code was very messy and extremely slow which caused me to decide to rewrite it from scratch. One of the biggest issues with the example code is that they do not use a full PID, instead they just use a P value. While this works fine for the majority of robots, if you wanted to go faster than about 30% speed a true PID implementation is required.\nState Machine Architecture I structured the program around a state machine with six states: START, RESTART, PATH, SHOOT, TURN, and DONE. This made the code significantly cleaner and easier to debug which I will give credit to the example code for doing partially correct. Each state has its own dedicated function that handles exactly what needs to happen in that phase of the run.\nThe robot starts in START, waiting for a button press. Once triggered, it transitions to PATH where the line following happens. When the bump sensors detect the wall, it moves to SHOOT, fires the duck launcher mechanism, then enters TURN to do a 180-degree spin. After turning, it goes back to PATH to return home. On the second bump which is hitting the robot resetters hand for faster reset times, it transitions to DONE and waits for a restart by pressing the front bumper again.\nFull PID Implementation A proper PID controller is needed to consistently follow the line at faster speeds. The key improvement over the example code was using actual time deltas for the integral and derivative calculations rather than assuming a fixed loop time. We tuned our constants to KP = 0.05, KI = 0.001, and KD = 0.01 which allowed us to run at 90% motor speed while still tracking the line accurately. These values differed per robot as they all were in different states of disrepair so we were never able to tune the PID to be as smooth as I wanted.\nfloat dt = (currentTime - lastPIDTime) / 1000.0; // Convert to seconds int error = linePos - GOAL; float P = KP * error; integral += error * dt; integral = constrain(integral, -1000, 1000); // Anti-windup float I = KI * integral; float derivative = (error - lastError) / dt; float D = KD * derivative; float motor_speed_delta = P + I + D; The integral term includes anti-windup clamping to prevent it from accumulating too much error when the robot is off the line for extended periods. We also reset the PID state (error, integral, and timing) whenever transitioning between states to prevent any weird behavior from stale values.\nShooter Control The shooting mechanism was very simple, just a digital pin that triggers a relay to trigger the motorized lever arm. A quick HIGH pulse for 300ms is all it takes to launch a duck into the pond. I added small delays before and after to ensure clean activation and so that we don\u0026rsquo;t brownout the robot which was an issue we had when trying to run both the wheels and shooter motor at the same time.\nThe full code can be view here on my github: DuckLaucher\nIts not very pretty as a good bit of it was redone the day of the competition for a slight optimization in the PID. There is also a very basic score keeping webpage, its only slightly broken.\nRetrospective Overall we did great and I\u0026rsquo;m very proud of my team for coming first out of over two thousand freshman engineers! The average score was probably less than 2-3k which we crushed, scoring 30,500 points with 81 ducks (44 in the 500, 24 in the 300, and 13 in the 100).\nThere were a lot of cool and unique designs that I saw and we learned a lot about what works and what should be avoided. If we were to do this again there are several things we would change.\nFirst off, our fears of the center getting filled were confirmed, but not due to other teams—our cycles were so fast that the center was filled about 2-3 minutes into the competition. This caused a lot of ducks to bounce out of the center off of other ducks and land in the 100 and 300 point sections. We had nearly perfect accuracy so all the ducks from the score breakdown in the other sections are due to them bouncing out of the center. The best way to avoid this would probably be to fine tune the launch angle so that it either goes at a more downward angle to bounce up again or go at a very shallow angle so that the ducks hit the back wall of the 500 point zone and bounce inwards. This is similar to what our launcher did but it could be improved. Another way could be instead of launching the ducks, have a way to drop or place them in the center which would prevent them from bouncing out and make it so they can be stacked higher before completely filling it up.\nSecond, the PID tuning process could be improved. Ideally the PID should be tuned on a straight line at the weight of the final robot, and even better with the robot that is going to be used during the competition. Realistically the latter isn\u0026rsquo;t possible but the first two are very achievable and I am annoyed I didn\u0026rsquo;t think to just bring electrical tape to the lab and make a straight line for tuning.\nThe last thing is the line sensor is so close to the wheels that the PID needs to have higher than normal values to compensate for the short response time that\u0026rsquo;s needed. This isn\u0026rsquo;t as essential since we were able to run at 90% speed and most likely could have gotten that higher with more time spent tuning, but if it\u0026rsquo;s possible to move the line sensor forwards then do so.\nA fun bonus tip is to 3D print or buy a second wheel for the robot as they normally only had one and it makes it significantly more stable and accurate.\nVideo of our competition Links\n","permalink":"http://localhost:1313/posts/duck-launcher/","summary":"How we made the highest scoring duck launcher.","title":"Duck Launcher"},{"content":" Hardware ESP32-C3 Super Mini Force Sensitive Resistor (FSR) 10K ohm Resistor 3D-Printed Case As I often use ESP32-C3 Super Minis in a lot of my projects due to their extremely small size I had already designed a slim case for them which worked prefectly for this application. The case can be found here on my MakerWorld Profile Page.\nWiring The wiring was very simple, I just soldered one pin of the FSR to 3.3v and then the other pin to a analog pin, in my case pin 4, with the resistor connecting pin 4 and ground.\nSoftware Using Esphome I wrote a basic yaml code to publish a resistor value as well as a binary occupancy value to HomeAssistant that can be found here.\n","permalink":"http://localhost:1313/posts/bed-occupancy-sensor/","summary":"Low cost bed occupancy sensor made with an esp32-c3 super mini and a $10 resistor.","title":"Bed Occupancy Sensor"},{"content":" I wanted an automated blind solution that wouldn\u0026rsquo;t rely on cloud services or expensive commercial products. By repurposing an IKEA roller shades and designing my own controller system, I was able to build a cheap local solution.\nHardware The smart blind consists of four main components:\n28BYJ-48 stepper motor ULN2003 stepper motor driver board ESP32 microcontroller IKEA roller shade I chose these because they were very cheap off of Amazon or Aliexpress and because the ULN2003 was supported by Esphome\u0026rsquo;s stepper component which I was planning on using to program the esp32.\n3D-Printed Case To mount and house the motor and eletronics I designed a 3d printed case in Fusion360. This was my first time cading gears so it took me a bit to get the correct gear ration that would allow the motor to have enough torque to raise the blinds without skipping. After that it was just a matter of blocking out where each component would go and build the case around them.\nWiring The wiring for the ULN2003 was rather straight forward and only needed 4 wires connected to the esp32 and then power and ground for both the driver and esp32\nSoftware To test that everything was working I wrote a quick arduino program to spin the motor in both directions for a few seconds. After confirming my wiring was correct and the code ran I started to write the Esphome code. During this process, I discovered that RoadKillUK had published a Github that was very similar to what I was trying to accomplish. I only had to modify the code slightly to work with an esp32 but it was pretty much perfect.\nUsage \u0026amp; Future Improvements I\u0026rsquo;ve been running the blind for a little over a year now and have had no issue with it so far. There are a few things that I would change if I made a second version. First, the blinds are slow, they take over a minuet to raise/lower about 3 feet. Second, the stepper motor loses its memory of the blind position if it loses power and will need to be re-homed.\n","permalink":"http://localhost:1313/posts/smart-blinds-v1/","summary":"Cheap, simple and effective smart blinds made from and old IKEA roller shades and a few electronic components.","title":"Smart Blinds"},{"content":"I’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\nMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003eI’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\u003c/p\u003e\n\u003cp\u003eMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\u003c/p\u003e","title":"About"},{"content":" Duck Launcher Final At UCF every freshman engineering student is split into groups of four and tasked with designing and programming a TI-RSLK robot to score as many little rubber ducks in the \u0026ldquo;pond\u0026rdquo; as fast as possible by following a black line to the pond within 10 minutes.\nThe pond is a large pentagon in the middle of 5 tracks that teams are trying to score into. There are 3 zones in the pond, each getting progressively smaller and worth more points; 100, 300, and 500 respectively. There are also penalty cups closest to the black line that add a time penalty if hit, and bonus cups at the start line that can be hit on the way back for a 50 point bonus every time.\nDesign Our main design goal was to score in the 500 point section as quickly as possible. We really wanted to get cycle times to be as quick as possible since we were worried about the small size of the center 500 point ring filling up and preventing us from scoring all the points possible. Some constraints we had to follow were that the robot must be against the pond wall before shooting a duck and the motors on the robot were rather weak, making it essential we keep the weight of our mechanisms to a minimum. We also needed to hit the wall perfectly perpendicular to make aiming more accurate.\nAfter testing out several design archetypes we settled on a motorized lever arm. This allowed us to quickly shoot ducks as soon as we hit the wall of the pond and was overall a very lightweight and compact mechanism. To fix the aiming issue we added a front bumper that went over the front two bump switches that forced the robot to go flat against the wall. We ended up going through seven versions, tweaking various gear ratios and arm lengths before we finally settled on the model we used. Here is the link to the CAD for anyone interested: CAD Model - Onshape\nProgramming Every group was provided with very basic but working example code. However, this code was very messy and extremely slow which caused me to decide to rewrite it from scratch. One of the biggest issues with the example code is that they do not use a full PID, instead they just use a P value. While this works fine for the majority of robots, if you wanted to go faster than about 30% speed a true PID implementation is required.\nState Machine Architecture I structured the program around a state machine with six states: START, RESTART, PATH, SHOOT, TURN, and DONE. This made the code significantly cleaner and easier to debug which I will give credit to the example code for doing partially correct. Each state has its own dedicated function that handles exactly what needs to happen in that phase of the run.\nThe robot starts in START, waiting for a button press. Once triggered, it transitions to PATH where the line following happens. When the bump sensors detect the wall, it moves to SHOOT, fires the duck launcher mechanism, then enters TURN to do a 180-degree spin. After turning, it goes back to PATH to return home. On the second bump which is hitting the robot resetters hand for faster reset times, it transitions to DONE and waits for a restart by pressing the front bumper again.\nFull PID Implementation A proper PID controller is needed to consistently follow the line at faster speeds. The key improvement over the example code was using actual time deltas for the integral and derivative calculations rather than assuming a fixed loop time. We tuned our constants to KP = 0.05, KI = 0.001, and KD = 0.01 which allowed us to run at 90% motor speed while still tracking the line accurately. These values differed per robot as they all were in different states of disrepair so we were never able to tune the PID to be as smooth as I wanted.\nfloat dt = (currentTime - lastPIDTime) / 1000.0; // Convert to seconds int error = linePos - GOAL; float P = KP * error; integral += error * dt; integral = constrain(integral, -1000, 1000); // Anti-windup float I = KI * integral; float derivative = (error - lastError) / dt; float D = KD * derivative; float motor_speed_delta = P + I + D; The integral term includes anti-windup clamping to prevent it from accumulating too much error when the robot is off the line for extended periods. We also reset the PID state (error, integral, and timing) whenever transitioning between states to prevent any weird behavior from stale values.\nShooter Control The shooting mechanism was very simple, just a digital pin that triggers a relay to trigger the motorized lever arm. A quick HIGH pulse for 300ms is all it takes to launch a duck into the pond. I added small delays before and after to ensure clean activation and so that we don\u0026rsquo;t brownout the robot which was an issue we had when trying to run both the wheels and shooter motor at the same time.\nThe full code can be view here on my github: DuckLaucher\nIts not very pretty as a good bit of it was redone the day of the competition for a slight optimization in the PID. There is also a very basic score keeping webpage, its only slightly broken.\nRetrospective Overall we did great and I\u0026rsquo;m very proud of my team for coming first out of over two thousand freshman engineers! The average score was probably less than 2-3k which we crushed, scoring 30,500 points with 81 ducks (44 in the 500, 24 in the 300, and 13 in the 100).\nThere were a lot of cool and unique designs that I saw and we learned a lot about what works and what should be avoided. If we were to do this again there are several things we would change.\nFirst off, our fears of the center getting filled were confirmed, but not due to other teams—our cycles were so fast that the center was filled about 2-3 minutes into the competition. This caused a lot of ducks to bounce out of the center off of other ducks and land in the 100 and 300 point sections. We had nearly perfect accuracy so all the ducks from the score breakdown in the other sections are due to them bouncing out of the center. The best way to avoid this would probably be to fine tune the launch angle so that it either goes at a more downward angle to bounce up again or go at a very shallow angle so that the ducks hit the back wall of the 500 point zone and bounce inwards. This is similar to what our launcher did but it could be improved. Another way could be instead of launching the ducks, have a way to drop or place them in the center which would prevent them from bouncing out and make it so they can be stacked higher before completely filling it up.\nSecond, the PID tuning process could be improved. Ideally the PID should be tuned on a straight line at the weight of the final robot, and even better with the robot that is going to be used during the competition. Realistically the latter isn\u0026rsquo;t possible but the first two are very achievable and I am annoyed I didn\u0026rsquo;t think to just bring electrical tape to the lab and make a straight line for tuning.\nThe last thing is the line sensor is so close to the wheels that the PID needs to have higher than normal values to compensate for the short response time that\u0026rsquo;s needed. This isn\u0026rsquo;t as essential since we were able to run at 90% speed and most likely could have gotten that higher with more time spent tuning, but if it\u0026rsquo;s possible to move the line sensor forwards then do so.\nA fun bonus tip is to 3D print or buy a second wheel for the robot as they normally only had one and it makes it significantly more stable and accurate.\nVideo of our competition Links\n","permalink":"http://localhost:1313/posts/duck-launcher/","summary":"How we made the highest scoring duck launcher.","title":"Duck Launcher"},{"content":" Hardware ESP32-C3 Super Mini Force Sensitive Resistor (FSR) 10K ohm Resistor 3D-Printed Case As I often use ESP32-C3 Super Minis in a lot of my projects due to their extremely small size I had already designed a slim case for them which worked prefectly for this application. The case can be found here on my MakerWorld Profile Page.\nWiring The wiring was very simple, I just soldered one pin of the FSR to 3.3v and then the other pin to a analog pin, in my case pin 4, with the resistor connecting pin 4 and ground.\nSoftware Using Esphome I wrote a basic yaml code to publish a resistor value as well as a binary occupancy value to HomeAssistant that can be found here.\n","permalink":"http://localhost:1313/posts/bed-occupancy-sensor/","summary":"Low cost bed occupancy sensor made with an esp32-c3 super mini and a $10 resistor.","title":"Bed Occupancy Sensor"},{"content":" I wanted an automated blind solution that wouldn\u0026rsquo;t rely on cloud services or expensive commercial products. By repurposing an IKEA roller shades and designing my own controller system, I was able to build a cheap local solution.\nHardware The smart blind consists of four main components:\n28BYJ-48 stepper motor ULN2003 stepper motor driver board ESP32 microcontroller IKEA roller shade I chose these because they were very cheap off of Amazon or Aliexpress and because the ULN2003 was supported by Esphome\u0026rsquo;s stepper component which I was planning on using to program the esp32.\n3D-Printed Case To mount and house the motor and eletronics I designed a 3d printed case in Fusion360. This was my first time cading gears so it took me a bit to get the correct gear ration that would allow the motor to have enough torque to raise the blinds without skipping. After that it was just a matter of blocking out where each component would go and build the case around them.\nWiring The wiring for the ULN2003 was rather straight forward and only needed 4 wires connected to the esp32 and then power and ground for both the driver and esp32\nSoftware To test that everything was working I wrote a quick arduino program to spin the motor in both directions for a few seconds. After confirming my wiring was correct and the code ran I started to write the Esphome code. During this process, I discovered that RoadKillUK had published a Github that was very similar to what I was trying to accomplish. I only had to modify the code slightly to work with an esp32 but it was pretty much perfect.\nUsage \u0026amp; Future Improvements I\u0026rsquo;ve been running the blind for a little over a year now and have had no issue with it so far. There are a few things that I would change if I made a second version. First, the blinds are slow, they take over a minuet to raise/lower about 3 feet. Second, the stepper motor loses its memory of the blind position if it loses power and will need to be re-homed.\n","permalink":"http://localhost:1313/posts/smart-blinds-v1/","summary":"Cheap, simple and effective smart blinds made from and old IKEA roller shades and a few electronic components.","title":"Smart Blinds"},{"content":"I’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\nMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003eI’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\u003c/p\u003e\n\u003cp\u003eMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\u003c/p\u003e","title":"About"},{"content":" Duck Launcher Final At UCF every freshman engineering student is split into groups of four and tasked with designing and programming a TI-RSLK robot to score as many little rubber ducks in the \u0026ldquo;pond\u0026rdquo; as fast as possible by following a black line to the pond within 10 minutes.\nThe pond is a large pentagon in the middle of 5 tracks that teams are trying to score into. There are 3 zones in the pond, each getting progressively smaller and worth more points; 100, 300, and 500 respectively. There are also penalty cups closest to the black line that add a time penalty if hit, and bonus cups at the start line that can be hit on the way back for a 50 point bonus every time.\nDesign Our main design goal was to score in the 500 point section as quickly as possible. We really wanted to get cycle times to be as quick as possible since we were worried about the small size of the center 500 point ring filling up and preventing us from scoring all the points possible. Some constraints we had to follow were that the robot must be against the pond wall before shooting a duck and the motors on the robot were rather weak, making it essential we keep the weight of our mechanisms to a minimum. We also needed to hit the wall perfectly perpendicular to make aiming more accurate.\nAfter testing out several design archetypes we settled on a motorized lever arm. This allowed us to quickly shoot ducks as soon as we hit the wall of the pond and was overall a very lightweight and compact mechanism. To fix the aiming issue we added a front bumper that went over the front two bump switches that forced the robot to go flat against the wall. We ended up going through seven versions, tweaking various gear ratios and arm lengths before we finally settled on the model we used. Here is the link to the CAD for anyone interested: CAD Model - Onshape\nProgramming Every group was provided with very basic but working example code. However, this code was very messy and extremely slow which caused me to decide to rewrite it from scratch. One of the biggest issues with the example code is that they do not use a full PID, instead they just use a P value. While this works fine for the majority of robots, if you wanted to go faster than about 30% speed a true PID implementation is required.\nState Machine Architecture I structured the program around a state machine with six states: START, RESTART, PATH, SHOOT, TURN, and DONE. This made the code significantly cleaner and easier to debug which I will give credit to the example code for doing partially correct. Each state has its own dedicated function that handles exactly what needs to happen in that phase of the run.\nThe robot starts in START, waiting for a button press. Once triggered, it transitions to PATH where the line following happens. When the bump sensors detect the wall, it moves to SHOOT, fires the duck launcher mechanism, then enters TURN to do a 180-degree spin. After turning, it goes back to PATH to return home. On the second bump which is hitting the robot resetters hand for faster reset times, it transitions to DONE and waits for a restart by pressing the front bumper again.\nFull PID Implementation A proper PID controller is needed to consistently follow the line at faster speeds. The key improvement over the example code was using actual time deltas for the integral and derivative calculations rather than assuming a fixed loop time. We tuned our constants to KP = 0.05, KI = 0.001, and KD = 0.01 which allowed us to run at 90% motor speed while still tracking the line accurately. These values differed per robot as they all were in different states of disrepair so we were never able to tune the PID to be as smooth as I wanted.\nfloat dt = (currentTime - lastPIDTime) / 1000.0; // Convert to seconds int error = linePos - GOAL; float P = KP * error; integral += error * dt; integral = constrain(integral, -1000, 1000); // Anti-windup float I = KI * integral; float derivative = (error - lastError) / dt; float D = KD * derivative; float motor_speed_delta = P + I + D; The integral term includes anti-windup clamping to prevent it from accumulating too much error when the robot is off the line for extended periods. We also reset the PID state (error, integral, and timing) whenever transitioning between states to prevent any weird behavior from stale values.\nShooter Control The shooting mechanism was very simple, just a digital pin that triggers a relay to trigger the motorized lever arm. A quick HIGH pulse for 300ms is all it takes to launch a duck into the pond. I added small delays before and after to ensure clean activation and so that we don\u0026rsquo;t brownout the robot which was an issue we had when trying to run both the wheels and shooter motor at the same time.\nThe full code can be view here on my github: DuckLaucher\nIts not very pretty as a good bit of it was redone the day of the competition for a slight optimization in the PID. There is also a very basic score keeping webpage, its only slightly broken.\nRetrospective Overall we did great and I\u0026rsquo;m very proud of my team for coming first out of over two thousand freshman engineers! The average score was probably less than 2-3k which we crushed, scoring 30,500 points with 81 ducks (44 in the 500, 24 in the 300, and 13 in the 100).\nThere were a lot of cool and unique designs that I saw and we learned a lot about what works and what should be avoided. If we were to do this again there are several things we would change.\nFirst off, our fears of the center getting filled were confirmed, but not due to other teams—our cycles were so fast that the center was filled about 2-3 minutes into the competition. This caused a lot of ducks to bounce out of the center off of other ducks and land in the 100 and 300 point sections. We had nearly perfect accuracy so all the ducks from the score breakdown in the other sections are due to them bouncing out of the center. The best way to avoid this would probably be to fine tune the launch angle so that it either goes at a more downward angle to bounce up again or go at a very shallow angle so that the ducks hit the back wall of the 500 point zone and bounce inwards. This is similar to what our launcher did but it could be improved. Another way could be instead of launching the ducks, have a way to drop or place them in the center which would prevent them from bouncing out and make it so they can be stacked higher before completely filling it up.\nSecond, the PID tuning process could be improved. Ideally the PID should be tuned on a straight line at the weight of the final robot, and even better with the robot that is going to be used during the competition. Realistically the latter isn\u0026rsquo;t possible but the first two are very achievable and I am annoyed I didn\u0026rsquo;t think to just bring electrical tape to the lab and make a straight line for tuning.\nThe last thing is the line sensor is so close to the wheels that the PID needs to have higher than normal values to compensate for the short response time that\u0026rsquo;s needed. This isn\u0026rsquo;t as essential since we were able to run at 90% speed and most likely could have gotten that higher with more time spent tuning, but if it\u0026rsquo;s possible to move the line sensor forwards then do so.\nA fun bonus tip is to 3D print or buy a second wheel for the robot as they normally only had one and it makes it significantly more stable and accurate.\nVideo of our competition Links: CAD Model - Onshape\n","permalink":"http://localhost:1313/posts/duck-launcher/","summary":"How we made the highest scoring duck launcher.","title":"Duck Launcher"},{"content":" Hardware ESP32-C3 Super Mini Force Sensitive Resistor (FSR) 10K ohm Resistor 3D-Printed Case As I often use ESP32-C3 Super Minis in a lot of my projects due to their extremely small size I had already designed a slim case for them which worked prefectly for this application. The case can be found here on my MakerWorld Profile Page.\nWiring The wiring was very simple, I just soldered one pin of the FSR to 3.3v and then the other pin to a analog pin, in my case pin 4, with the resistor connecting pin 4 and ground.\nSoftware Using Esphome I wrote a basic yaml code to publish a resistor value as well as a binary occupancy value to HomeAssistant that can be found here.\n","permalink":"http://localhost:1313/posts/bed-occupancy-sensor/","summary":"Low cost bed occupancy sensor made with an esp32-c3 super mini and a $10 resistor.","title":"Bed Occupancy Sensor"},{"content":" I wanted an automated blind solution that wouldn\u0026rsquo;t rely on cloud services or expensive commercial products. By repurposing an IKEA roller shades and designing my own controller system, I was able to build a cheap local solution.\nHardware The smart blind consists of four main components:\n28BYJ-48 stepper motor ULN2003 stepper motor driver board ESP32 microcontroller IKEA roller shade I chose these because they were very cheap off of Amazon or Aliexpress and because the ULN2003 was supported by Esphome\u0026rsquo;s stepper component which I was planning on using to program the esp32.\n3D-Printed Case To mount and house the motor and eletronics I designed a 3d printed case in Fusion360. This was my first time cading gears so it took me a bit to get the correct gear ration that would allow the motor to have enough torque to raise the blinds without skipping. After that it was just a matter of blocking out where each component would go and build the case around them.\nWiring The wiring for the ULN2003 was rather straight forward and only needed 4 wires connected to the esp32 and then power and ground for both the driver and esp32\nSoftware To test that everything was working I wrote a quick arduino program to spin the motor in both directions for a few seconds. After confirming my wiring was correct and the code ran I started to write the Esphome code. During this process, I discovered that RoadKillUK had published a Github that was very similar to what I was trying to accomplish. I only had to modify the code slightly to work with an esp32 but it was pretty much perfect.\nUsage \u0026amp; Future Improvements I\u0026rsquo;ve been running the blind for a little over a year now and have had no issue with it so far. There are a few things that I would change if I made a second version. First, the blinds are slow, they take over a minuet to raise/lower about 3 feet. Second, the stepper motor loses its memory of the blind position if it loses power and will need to be re-homed.\n","permalink":"http://localhost:1313/posts/smart-blinds-v1/","summary":"Cheap, simple and effective smart blinds made from and old IKEA roller shades and a few electronic components.","title":"Smart Blinds"},{"content":"I’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\nMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003eI’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\u003c/p\u003e\n\u003cp\u003eMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\u003c/p\u003e","title":"About"},{"content":" Duck Launcher Final At UCF every freshman engineering student is split into groups of four and tasked with designing and programming a TI-RSLK robot to score as many little rubber ducks in the \u0026ldquo;pond\u0026rdquo; as fast as possible by following a black line to the pond within 10 minutes.\nThe pond is a large pentagon in the middle of 5 tracks that teams are trying to score into. There are 3 zones in the pond, each getting progressively smaller and worth more points; 100, 300, and 500 respectively. There are also penalty cups closest to the black line that add a time penalty if hit, and bonus cups at the start line that can be hit on the way back for a 50 point bonus every time.\nDesign Our main design goal was to score in the 500 point section as quickly as possible. We really wanted to get cycle times to be as quick as possible since we were worried about the small size of the center 500 point ring filling up and preventing us from scoring all the points possible. Some constraints we had to follow were that the robot must be against the pond wall before shooting a duck and the motors on the robot were rather weak, making it essential we keep the weight of our mechanisms to a minimum. We also needed to hit the wall perfectly perpendicular to make aiming more accurate.\nAfter testing out several design archetypes we settled on a motorized lever arm. This allowed us to quickly shoot ducks as soon as we hit the wall of the pond and was overall a very lightweight and compact mechanism. To fix the aiming issue we added a front bumper that went over the front two bump switches that forced the robot to go flat against the wall. We ended up going through seven versions, tweaking various gear ratios and arm lengths before we finally settled on the model we used. Here is the link to the CAD for anyone interested: CAD Model - Onshape\nProgramming Every group was provided with very basic but working example code. However, this code was very messy and extremely slow which caused me to decide to rewrite it from scratch. One of the biggest issues with the example code is that they do not use a full PID, instead they just use a P value. While this works fine for the majority of robots, if you wanted to go faster than about 30% speed a true PID implementation is required.\nState Machine Architecture I structured the program around a state machine with six states: START, RESTART, PATH, SHOOT, TURN, and DONE. This made the code significantly cleaner and easier to debug which I will give credit to the example code for doing partially correct. Each state has its own dedicated function that handles exactly what needs to happen in that phase of the run.\nThe robot starts in START, waiting for a button press. Once triggered, it transitions to PATH where the line following happens. When the bump sensors detect the wall, it moves to SHOOT, fires the duck launcher mechanism, then enters TURN to do a 180-degree spin. After turning, it goes back to PATH to return home. On the second bump which is hitting the robot resetters hand for faster reset times, it transitions to DONE and waits for a restart by pressing the front bumper again.\nFull PID Implementation A proper PID controller is needed to consistently follow the line at faster speeds. The key improvement over the example code was using actual time deltas for the integral and derivative calculations rather than assuming a fixed loop time. We tuned our constants to KP = 0.05, KI = 0.001, and KD = 0.01 which allowed us to run at 90% motor speed while still tracking the line accurately. These values differed per robot as they all were in different states of disrepair so we were never able to tune the PID to be as smooth as I wanted.\nfloat dt = (currentTime - lastPIDTime) / 1000.0; // Convert to seconds int error = linePos - GOAL; float P = KP * error; integral += error * dt; integral = constrain(integral, -1000, 1000); // Anti-windup float I = KI * integral; float derivative = (error - lastError) / dt; float D = KD * derivative; float motor_speed_delta = P + I + D; The integral term includes anti-windup clamping to prevent it from accumulating too much error when the robot is off the line for extended periods. We also reset the PID state (error, integral, and timing) whenever transitioning between states to prevent any weird behavior from stale values.\nShooter Control The shooting mechanism was very simple, just a digital pin that triggers a relay to trigger the motorized lever arm. A quick HIGH pulse for 300ms is all it takes to launch a duck into the pond. I added small delays before and after to ensure clean activation and so that we don\u0026rsquo;t brownout the robot which was an issue we had when trying to run both the wheels and shooter motor at the same time.\nThe full code can be view here on my github: DuckLaucher\nIts not very pretty as a good bit of it was redone the day of the competition for a slight optimization in the PID. There is also a very basic score keeping webpage, its only slightly broken.\nRetrospective Overall we did great and I\u0026rsquo;m very proud of my team for coming first out of over two thousand freshman engineers! The average score was probably less than 2-3k which we crushed, scoring 30,500 points with 81 ducks (44 in the 500, 24 in the 300, and 13 in the 100).\nThere were a lot of cool and unique designs that I saw and we learned a lot about what works and what should be avoided. If we were to do this again there are several things we would change.\nFirst off, our fears of the center getting filled were confirmed, but not due to other teams—our cycles were so fast that the center was filled about 2-3 minutes into the competition. This caused a lot of ducks to bounce out of the center off of other ducks and land in the 100 and 300 point sections. We had nearly perfect accuracy so all the ducks from the score breakdown in the other sections are due to them bouncing out of the center. The best way to avoid this would probably be to fine tune the launch angle so that it either goes at a more downward angle to bounce up again or go at a very shallow angle so that the ducks hit the back wall of the 500 point zone and bounce inwards. This is similar to what our launcher did but it could be improved. Another way could be instead of launching the ducks, have a way to drop or place them in the center which would prevent them from bouncing out and make it so they can be stacked higher before completely filling it up.\nSecond, the PID tuning process could be improved. Ideally the PID should be tuned on a straight line at the weight of the final robot, and even better with the robot that is going to be used during the competition. Realistically the latter isn\u0026rsquo;t possible but the first two are very achievable and I am annoyed I didn\u0026rsquo;t think to just bring electrical tape to the lab and make a straight line for tuning.\nThe last thing is the line sensor is so close to the wheels that the PID needs to have higher than normal values to compensate for the short response time that\u0026rsquo;s needed. This isn\u0026rsquo;t as essential since we were able to run at 90% speed and most likely could have gotten that higher with more time spent tuning, but if it\u0026rsquo;s possible to move the line sensor forwards then do so.\nA fun bonus tip is to 3D print or buy a second wheel for the robot as they normally only had one and it makes it significantly more stable and accurate.\nVideo of our competition Links:\nCAD Model - Onshape\n","permalink":"http://localhost:1313/posts/duck-launcher/","summary":"How we made the highest scoring duck launcher.","title":"Duck Launcher"},{"content":" Hardware ESP32-C3 Super Mini Force Sensitive Resistor (FSR) 10K ohm Resistor 3D-Printed Case As I often use ESP32-C3 Super Minis in a lot of my projects due to their extremely small size I had already designed a slim case for them which worked prefectly for this application. The case can be found here on my MakerWorld Profile Page.\nWiring The wiring was very simple, I just soldered one pin of the FSR to 3.3v and then the other pin to a analog pin, in my case pin 4, with the resistor connecting pin 4 and ground.\nSoftware Using Esphome I wrote a basic yaml code to publish a resistor value as well as a binary occupancy value to HomeAssistant that can be found here.\n","permalink":"http://localhost:1313/posts/bed-occupancy-sensor/","summary":"Low cost bed occupancy sensor made with an esp32-c3 super mini and a $10 resistor.","title":"Bed Occupancy Sensor"},{"content":" I wanted an automated blind solution that wouldn\u0026rsquo;t rely on cloud services or expensive commercial products. By repurposing an IKEA roller shades and designing my own controller system, I was able to build a cheap local solution.\nHardware The smart blind consists of four main components:\n28BYJ-48 stepper motor ULN2003 stepper motor driver board ESP32 microcontroller IKEA roller shade I chose these because they were very cheap off of Amazon or Aliexpress and because the ULN2003 was supported by Esphome\u0026rsquo;s stepper component which I was planning on using to program the esp32.\n3D-Printed Case To mount and house the motor and eletronics I designed a 3d printed case in Fusion360. This was my first time cading gears so it took me a bit to get the correct gear ration that would allow the motor to have enough torque to raise the blinds without skipping. After that it was just a matter of blocking out where each component would go and build the case around them.\nWiring The wiring for the ULN2003 was rather straight forward and only needed 4 wires connected to the esp32 and then power and ground for both the driver and esp32\nSoftware To test that everything was working I wrote a quick arduino program to spin the motor in both directions for a few seconds. After confirming my wiring was correct and the code ran I started to write the Esphome code. During this process, I discovered that RoadKillUK had published a Github that was very similar to what I was trying to accomplish. I only had to modify the code slightly to work with an esp32 but it was pretty much perfect.\nUsage \u0026amp; Future Improvements I\u0026rsquo;ve been running the blind for a little over a year now and have had no issue with it so far. There are a few things that I would change if I made a second version. First, the blinds are slow, they take over a minuet to raise/lower about 3 feet. Second, the stepper motor loses its memory of the blind position if it loses power and will need to be re-homed.\n","permalink":"http://localhost:1313/posts/smart-blinds-v1/","summary":"Cheap, simple and effective smart blinds made from and old IKEA roller shades and a few electronic components.","title":"Smart Blinds"},{"content":"I’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\nMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003eI’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\u003c/p\u003e\n\u003cp\u003eMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\u003c/p\u003e","title":"About"},{"content":" Duck Launcher Final At UCF every freshman engineering student is split into groups of four and tasked with designing and programming a TI-RSLK robot to score as many little rubber ducks in the \u0026ldquo;pond\u0026rdquo; as fast as possible by following a black line to the pond within 10 minutes.\nThe pond is a large pentagon in the middle of 5 tracks that teams are trying to score into. There are 3 zones in the pond, each getting progressively smaller and worth more points; 100, 300, and 500 respectively. There are also penalty cups closest to the black line that add a time penalty if hit, and bonus cups at the start line that can be hit on the way back for a 50 point bonus every time.\nDesign Our main design goal was to score in the 500 point section as quickly as possible. We really wanted to get cycle times to be as quick as possible since we were worried about the small size of the center 500 point ring filling up and preventing us from scoring all the points possible. Some constraints we had to follow were that the robot must be against the pond wall before shooting a duck and the motors on the robot were rather weak, making it essential we keep the weight of our mechanisms to a minimum. We also needed to hit the wall perfectly perpendicular to make aiming more accurate.\nAfter testing out several design archetypes we settled on a motorized lever arm. This allowed us to quickly shoot ducks as soon as we hit the wall of the pond and was overall a very lightweight and compact mechanism. To fix the aiming issue we added a front bumper that went over the front two bump switches that forced the robot to go flat against the wall. We ended up going through seven versions, tweaking various gear ratios and arm lengths before we finally settled on the model we used. Here is the link to the CAD for anyone interested: CAD Model - Onshape\nProgramming Every group was provided with very basic but working example code. However, this code was very messy and extremely slow which caused me to decide to rewrite it from scratch. One of the biggest issues with the example code is that they do not use a full PID, instead they just use a P value. While this works fine for the majority of robots, if you wanted to go faster than about 30% speed a true PID implementation is required.\nState Machine Architecture I structured the program around a state machine with six states: START, RESTART, PATH, SHOOT, TURN, and DONE. This made the code significantly cleaner and easier to debug which I will give credit to the example code for doing partially correct. Each state has its own dedicated function that handles exactly what needs to happen in that phase of the run.\nThe robot starts in START, waiting for a button press. Once triggered, it transitions to PATH where the line following happens. When the bump sensors detect the wall, it moves to SHOOT, fires the duck launcher mechanism, then enters TURN to do a 180-degree spin. After turning, it goes back to PATH to return home. On the second bump which is hitting the robot resetters hand for faster reset times, it transitions to DONE and waits for a restart by pressing the front bumper again.\nFull PID Implementation A proper PID controller is needed to consistently follow the line at faster speeds. The key improvement over the example code was using actual time deltas for the integral and derivative calculations rather than assuming a fixed loop time. We tuned our constants to KP = 0.05, KI = 0.001, and KD = 0.01 which allowed us to run at 90% motor speed while still tracking the line accurately. These values differed per robot as they all were in different states of disrepair so we were never able to tune the PID to be as smooth as I wanted.\nfloat dt = (currentTime - lastPIDTime) / 1000.0; // Convert to seconds int error = linePos - GOAL; float P = KP * error; integral += error * dt; integral = constrain(integral, -1000, 1000); // Anti-windup float I = KI * integral; float derivative = (error - lastError) / dt; float D = KD * derivative; float motor_speed_delta = P + I + D; The integral term includes anti-windup clamping to prevent it from accumulating too much error when the robot is off the line for extended periods. We also reset the PID state (error, integral, and timing) whenever transitioning between states to prevent any weird behavior from stale values.\nShooter Control The shooting mechanism was very simple, just a digital pin that triggers a relay to trigger the motorized lever arm. A quick HIGH pulse for 300ms is all it takes to launch a duck into the pond. I added small delays before and after to ensure clean activation and so that we don\u0026rsquo;t brownout the robot which was an issue we had when trying to run both the wheels and shooter motor at the same time.\nThe full code can be view here on my github: DuckLaucher\nIts not very pretty as a good bit of it was redone the day of the competition for a slight optimization in the PID. There is also a very basic score keeping webpage, its only slightly broken.\nRetrospective Overall we did great and I\u0026rsquo;m very proud of my team for coming first out of over two thousand freshman engineers! The average score was probably less than 2-3k which we crushed, scoring 30,500 points with 81 ducks (44 in the 500, 24 in the 300, and 13 in the 100).\nThere were a lot of cool and unique designs that I saw and we learned a lot about what works and what should be avoided. If we were to do this again there are several things we would change.\nFirst off, our fears of the center getting filled were confirmed, but not due to other teams—our cycles were so fast that the center was filled about 2-3 minutes into the competition. This caused a lot of ducks to bounce out of the center off of other ducks and land in the 100 and 300 point sections. We had nearly perfect accuracy so all the ducks from the score breakdown in the other sections are due to them bouncing out of the center. The best way to avoid this would probably be to fine tune the launch angle so that it either goes at a more downward angle to bounce up again or go at a very shallow angle so that the ducks hit the back wall of the 500 point zone and bounce inwards. This is similar to what our launcher did but it could be improved. Another way could be instead of launching the ducks, have a way to drop or place them in the center which would prevent them from bouncing out and make it so they can be stacked higher before completely filling it up.\nSecond, the PID tuning process could be improved. Ideally the PID should be tuned on a straight line at the weight of the final robot, and even better with the robot that is going to be used during the competition. Realistically the latter isn\u0026rsquo;t possible but the first two are very achievable and I am annoyed I didn\u0026rsquo;t think to just bring electrical tape to the lab and make a straight line for tuning.\nThe last thing is the line sensor is so close to the wheels that the PID needs to have higher than normal values to compensate for the short response time that\u0026rsquo;s needed. This isn\u0026rsquo;t as essential since we were able to run at 90% speed and most likely could have gotten that higher with more time spent tuning, but if it\u0026rsquo;s possible to move the line sensor forwards then do so.\nA fun bonus tip is to 3D print or buy a second wheel for the robot as they normally only had one and it makes it significantly more stable and accurate.\nVideo of our competition Links:\nCAD Model - Onshape DuckLaucher ","permalink":"http://localhost:1313/posts/duck-launcher/","summary":"How we made the highest scoring duck launcher.","title":"Duck Launcher"},{"content":" Hardware ESP32-C3 Super Mini Force Sensitive Resistor (FSR) 10K ohm Resistor 3D-Printed Case As I often use ESP32-C3 Super Minis in a lot of my projects due to their extremely small size I had already designed a slim case for them which worked prefectly for this application. The case can be found here on my MakerWorld Profile Page.\nWiring The wiring was very simple, I just soldered one pin of the FSR to 3.3v and then the other pin to a analog pin, in my case pin 4, with the resistor connecting pin 4 and ground.\nSoftware Using Esphome I wrote a basic yaml code to publish a resistor value as well as a binary occupancy value to HomeAssistant that can be found here.\n","permalink":"http://localhost:1313/posts/bed-occupancy-sensor/","summary":"Low cost bed occupancy sensor made with an esp32-c3 super mini and a $10 resistor.","title":"Bed Occupancy Sensor"},{"content":" I wanted an automated blind solution that wouldn\u0026rsquo;t rely on cloud services or expensive commercial products. By repurposing an IKEA roller shades and designing my own controller system, I was able to build a cheap local solution.\nHardware The smart blind consists of four main components:\n28BYJ-48 stepper motor ULN2003 stepper motor driver board ESP32 microcontroller IKEA roller shade I chose these because they were very cheap off of Amazon or Aliexpress and because the ULN2003 was supported by Esphome\u0026rsquo;s stepper component which I was planning on using to program the esp32.\n3D-Printed Case To mount and house the motor and eletronics I designed a 3d printed case in Fusion360. This was my first time cading gears so it took me a bit to get the correct gear ration that would allow the motor to have enough torque to raise the blinds without skipping. After that it was just a matter of blocking out where each component would go and build the case around them.\nWiring The wiring for the ULN2003 was rather straight forward and only needed 4 wires connected to the esp32 and then power and ground for both the driver and esp32\nSoftware To test that everything was working I wrote a quick arduino program to spin the motor in both directions for a few seconds. After confirming my wiring was correct and the code ran I started to write the Esphome code. During this process, I discovered that RoadKillUK had published a Github that was very similar to what I was trying to accomplish. I only had to modify the code slightly to work with an esp32 but it was pretty much perfect.\nUsage \u0026amp; Future Improvements I\u0026rsquo;ve been running the blind for a little over a year now and have had no issue with it so far. There are a few things that I would change if I made a second version. First, the blinds are slow, they take over a minuet to raise/lower about 3 feet. Second, the stepper motor loses its memory of the blind position if it loses power and will need to be re-homed.\n","permalink":"http://localhost:1313/posts/smart-blinds-v1/","summary":"Cheap, simple and effective smart blinds made from and old IKEA roller shades and a few electronic components.","title":"Smart Blinds"},{"content":"I’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\nMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003eI’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\u003c/p\u003e\n\u003cp\u003eMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\u003c/p\u003e","title":"About"},{"content":" Duck Launcher Final At UCF every freshman engineering student is split into groups of four and tasked with designing and programming a TI-RSLK robot to score as many little rubber ducks in the \u0026ldquo;pond\u0026rdquo; as fast as possible by following a black line to the pond within 10 minutes.\nThe pond is a large pentagon in the middle of 5 tracks that teams are trying to score into. There are 3 zones in the pond, each getting progressively smaller and worth more points; 100, 300, and 500 respectively. There are also penalty cups closest to the black line that add a time penalty if hit, and bonus cups at the start line that can be hit on the way back for a 50 point bonus every time.\nDesign Our main design goal was to score in the 500 point section as quickly as possible. We really wanted to get cycle times to be as quick as possible since we were worried about the small size of the center 500 point ring filling up and preventing us from scoring all the points possible. Some constraints we had to follow were that the robot must be against the pond wall before shooting a duck and the motors on the robot were rather weak, making it essential we keep the weight of our mechanisms to a minimum. We also needed to hit the wall perfectly perpendicular to make aiming more accurate.\nAfter testing out several design archetypes we settled on a motorized lever arm. This allowed us to quickly shoot ducks as soon as we hit the wall of the pond and was overall a very lightweight and compact mechanism. To fix the aiming issue we added a front bumper that went over the front two bump switches that forced the robot to go flat against the wall. We ended up going through seven versions, tweaking various gear ratios and arm lengths before we finally settled on the model we used. Here is the link to the CAD for anyone interested: CAD Model - Onshape\nProgramming Every group was provided with very basic but working example code. However, this code was very messy and extremely slow which caused me to decide to rewrite it from scratch. One of the biggest issues with the example code is that they do not use a full PID, instead they just use a P value. While this works fine for the majority of robots, if you wanted to go faster than about 30% speed a true PID implementation is required.\nState Machine Architecture I structured the program around a state machine with six states: START, RESTART, PATH, SHOOT, TURN, and DONE. This made the code significantly cleaner and easier to debug which I will give credit to the example code for doing partially correct. Each state has its own dedicated function that handles exactly what needs to happen in that phase of the run.\nThe robot starts in START, waiting for a button press. Once triggered, it transitions to PATH where the line following happens. When the bump sensors detect the wall, it moves to SHOOT, fires the duck launcher mechanism, then enters TURN to do a 180-degree spin. After turning, it goes back to PATH to return home. On the second bump which is hitting the robot resetters hand for faster reset times, it transitions to DONE and waits for a restart by pressing the front bumper again.\nFull PID Implementation A proper PID controller is needed to consistently follow the line at faster speeds. The key improvement over the example code was using actual time deltas for the integral and derivative calculations rather than assuming a fixed loop time. We tuned our constants to KP = 0.05, KI = 0.001, and KD = 0.01 which allowed us to run at 90% motor speed while still tracking the line accurately. These values differed per robot as they all were in different states of disrepair so we were never able to tune the PID to be as smooth as I wanted.\nfloat dt = (currentTime - lastPIDTime) / 1000.0; // Convert to seconds int error = linePos - GOAL; float P = KP * error; integral += error * dt; integral = constrain(integral, -1000, 1000); // Anti-windup float I = KI * integral; float derivative = (error - lastError) / dt; float D = KD * derivative; float motor_speed_delta = P + I + D; The integral term includes anti-windup clamping to prevent it from accumulating too much error when the robot is off the line for extended periods. We also reset the PID state (error, integral, and timing) whenever transitioning between states to prevent any weird behavior from stale values.\nShooter Control The shooting mechanism was very simple, just a digital pin that triggers a relay to trigger the motorized lever arm. A quick HIGH pulse for 300ms is all it takes to launch a duck into the pond. I added small delays before and after to ensure clean activation and so that we don\u0026rsquo;t brownout the robot which was an issue we had when trying to run both the wheels and shooter motor at the same time.\nThe full code can be view here on my github: DuckLaucher\nIts not very pretty as a good bit of it was redone the day of the competition for a slight optimization in the PID. There is also a very basic score keeping webpage, its only slightly broken.\nRetrospective Overall we did great and I\u0026rsquo;m very proud of my team for coming first out of over two thousand freshman engineers! The average score was probably less than 2-3k which we crushed, scoring 30,500 points with 81 ducks (44 in the 500, 24 in the 300, and 13 in the 100).\nThere were a lot of cool and unique designs that I saw and we learned a lot about what works and what should be avoided. If we were to do this again there are several things we would change.\nFirst off, our fears of the center getting filled were confirmed, but not due to other teams—our cycles were so fast that the center was filled about 2-3 minutes into the competition. This caused a lot of ducks to bounce out of the center off of other ducks and land in the 100 and 300 point sections. We had nearly perfect accuracy so all the ducks from the score breakdown in the other sections are due to them bouncing out of the center. The best way to avoid this would probably be to fine tune the launch angle so that it either goes at a more downward angle to bounce up again or go at a very shallow angle so that the ducks hit the back wall of the 500 point zone and bounce inwards. This is similar to what our launcher did but it could be improved. Another way could be instead of launching the ducks, have a way to drop or place them in the center which would prevent them from bouncing out and make it so they can be stacked higher before completely filling it up.\nSecond, the PID tuning process could be improved. Ideally the PID should be tuned on a straight line at the weight of the final robot, and even better with the robot that is going to be used during the competition. Realistically the latter isn\u0026rsquo;t possible but the first two are very achievable and I am annoyed I didn\u0026rsquo;t think to just bring electrical tape to the lab and make a straight line for tuning.\nThe last thing is the line sensor is so close to the wheels that the PID needs to have higher than normal values to compensate for the short response time that\u0026rsquo;s needed. This isn\u0026rsquo;t as essential since we were able to run at 90% speed and most likely could have gotten that higher with more time spent tuning, but if it\u0026rsquo;s possible to move the line sensor forwards then do so.\nA fun bonus tip is to 3D print or buy a second wheel for the robot as they normally only had one and it makes it significantly more stable and accurate.\nVideo of our competition Links:\nCAD Model - Onshape\nDuckLaucher ","permalink":"http://localhost:1313/posts/duck-launcher/","summary":"How we made the highest scoring duck launcher.","title":"Duck Launcher"},{"content":" Hardware ESP32-C3 Super Mini Force Sensitive Resistor (FSR) 10K ohm Resistor 3D-Printed Case As I often use ESP32-C3 Super Minis in a lot of my projects due to their extremely small size I had already designed a slim case for them which worked prefectly for this application. The case can be found here on my MakerWorld Profile Page.\nWiring The wiring was very simple, I just soldered one pin of the FSR to 3.3v and then the other pin to a analog pin, in my case pin 4, with the resistor connecting pin 4 and ground.\nSoftware Using Esphome I wrote a basic yaml code to publish a resistor value as well as a binary occupancy value to HomeAssistant that can be found here.\n","permalink":"http://localhost:1313/posts/bed-occupancy-sensor/","summary":"Low cost bed occupancy sensor made with an esp32-c3 super mini and a $10 resistor.","title":"Bed Occupancy Sensor"},{"content":" I wanted an automated blind solution that wouldn\u0026rsquo;t rely on cloud services or expensive commercial products. By repurposing an IKEA roller shades and designing my own controller system, I was able to build a cheap local solution.\nHardware The smart blind consists of four main components:\n28BYJ-48 stepper motor ULN2003 stepper motor driver board ESP32 microcontroller IKEA roller shade I chose these because they were very cheap off of Amazon or Aliexpress and because the ULN2003 was supported by Esphome\u0026rsquo;s stepper component which I was planning on using to program the esp32.\n3D-Printed Case To mount and house the motor and eletronics I designed a 3d printed case in Fusion360. This was my first time cading gears so it took me a bit to get the correct gear ration that would allow the motor to have enough torque to raise the blinds without skipping. After that it was just a matter of blocking out where each component would go and build the case around them.\nWiring The wiring for the ULN2003 was rather straight forward and only needed 4 wires connected to the esp32 and then power and ground for both the driver and esp32\nSoftware To test that everything was working I wrote a quick arduino program to spin the motor in both directions for a few seconds. After confirming my wiring was correct and the code ran I started to write the Esphome code. During this process, I discovered that RoadKillUK had published a Github that was very similar to what I was trying to accomplish. I only had to modify the code slightly to work with an esp32 but it was pretty much perfect.\nUsage \u0026amp; Future Improvements I\u0026rsquo;ve been running the blind for a little over a year now and have had no issue with it so far. There are a few things that I would change if I made a second version. First, the blinds are slow, they take over a minuet to raise/lower about 3 feet. Second, the stepper motor loses its memory of the blind position if it loses power and will need to be re-homed.\n","permalink":"http://localhost:1313/posts/smart-blinds-v1/","summary":"Cheap, simple and effective smart blinds made from and old IKEA roller shades and a few electronic components.","title":"Smart Blinds"},{"content":"I’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\nMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003eI’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\u003c/p\u003e\n\u003cp\u003eMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\u003c/p\u003e","title":"About"},{"content":" Duck Launcher Final At UCF every freshman engineering student is split into groups of four and tasked with designing and programming a TI-RSLK robot to score as many little rubber ducks in the \u0026ldquo;pond\u0026rdquo; as fast as possible by following a black line to the pond within 10 minutes.\nThe pond is a large pentagon in the middle of 5 tracks that teams are trying to score into. There are 3 zones in the pond, each getting progressively smaller and worth more points; 100, 300, and 500 respectively. There are also penalty cups closest to the black line that add a time penalty if hit, and bonus cups at the start line that can be hit on the way back for a 50 point bonus every time.\nDesign Our main design goal was to score in the 500 point section as quickly as possible. We really wanted to get cycle times to be as quick as possible since we were worried about the small size of the center 500 point ring filling up and preventing us from scoring all the points possible. Some constraints we had to follow were that the robot must be against the pond wall before shooting a duck and the motors on the robot were rather weak, making it essential we keep the weight of our mechanisms to a minimum. We also needed to hit the wall perfectly perpendicular to make aiming more accurate.\nAfter testing out several design archetypes we settled on a motorized lever arm. This allowed us to quickly shoot ducks as soon as we hit the wall of the pond and was overall a very lightweight and compact mechanism. To fix the aiming issue we added a front bumper that went over the front two bump switches that forced the robot to go flat against the wall. We ended up going through seven versions, tweaking various gear ratios and arm lengths before we finally settled on the model we used. Here is the link to the CAD for anyone interested: CAD Model - Onshape\nProgramming Every group was provided with very basic but working example code. However, this code was very messy and extremely slow which caused me to decide to rewrite it from scratch. One of the biggest issues with the example code is that they do not use a full PID, instead they just use a P value. While this works fine for the majority of robots, if you wanted to go faster than about 30% speed a true PID implementation is required.\nState Machine Architecture I structured the program around a state machine with six states: START, RESTART, PATH, SHOOT, TURN, and DONE. This made the code significantly cleaner and easier to debug which I will give credit to the example code for doing partially correct. Each state has its own dedicated function that handles exactly what needs to happen in that phase of the run.\nThe robot starts in START, waiting for a button press. Once triggered, it transitions to PATH where the line following happens. When the bump sensors detect the wall, it moves to SHOOT, fires the duck launcher mechanism, then enters TURN to do a 180-degree spin. After turning, it goes back to PATH to return home. On the second bump which is hitting the robot resetters hand for faster reset times, it transitions to DONE and waits for a restart by pressing the front bumper again.\nFull PID Implementation A proper PID controller is needed to consistently follow the line at faster speeds. The key improvement over the example code was using actual time deltas for the integral and derivative calculations rather than assuming a fixed loop time. We tuned our constants to KP = 0.05, KI = 0.001, and KD = 0.01 which allowed us to run at 90% motor speed while still tracking the line accurately. These values differed per robot as they all were in different states of disrepair so we were never able to tune the PID to be as smooth as I wanted.\nfloat dt = (currentTime - lastPIDTime) / 1000.0; // Convert to seconds int error = linePos - GOAL; float P = KP * error; integral += error * dt; integral = constrain(integral, -1000, 1000); // Anti-windup float I = KI * integral; float derivative = (error - lastError) / dt; float D = KD * derivative; float motor_speed_delta = P + I + D; The integral term includes anti-windup clamping to prevent it from accumulating too much error when the robot is off the line for extended periods. We also reset the PID state (error, integral, and timing) whenever transitioning between states to prevent any weird behavior from stale values.\nShooter Control The shooting mechanism was very simple, just a digital pin that triggers a relay to trigger the motorized lever arm. A quick HIGH pulse for 300ms is all it takes to launch a duck into the pond. I added small delays before and after to ensure clean activation and so that we don\u0026rsquo;t brownout the robot which was an issue we had when trying to run both the wheels and shooter motor at the same time.\nThe full code can be view here on my github: DuckLaucher\nIts not very pretty as a good bit of it was redone the day of the competition for a slight optimization in the PID. There is also a very basic score keeping webpage, its only slightly broken.\nRetrospective Overall we did great and I\u0026rsquo;m very proud of my team for coming first out of over two thousand freshman engineers! The average score was probably less than 2-3k which we crushed, scoring 30,500 points with 81 ducks (44 in the 500, 24 in the 300, and 13 in the 100).\nThere were a lot of cool and unique designs that I saw and we learned a lot about what works and what should be avoided. If we were to do this again there are several things we would change.\nFirst off, our fears of the center getting filled were confirmed, but not due to other teams—our cycles were so fast that the center was filled about 2-3 minutes into the competition. This caused a lot of ducks to bounce out of the center off of other ducks and land in the 100 and 300 point sections. We had nearly perfect accuracy so all the ducks from the score breakdown in the other sections are due to them bouncing out of the center. The best way to avoid this would probably be to fine tune the launch angle so that it either goes at a more downward angle to bounce up again or go at a very shallow angle so that the ducks hit the back wall of the 500 point zone and bounce inwards. This is similar to what our launcher did but it could be improved. Another way could be instead of launching the ducks, have a way to drop or place them in the center which would prevent them from bouncing out and make it so they can be stacked higher before completely filling it up.\nSecond, the PID tuning process could be improved. Ideally the PID should be tuned on a straight line at the weight of the final robot, and even better with the robot that is going to be used during the competition. Realistically the latter isn\u0026rsquo;t possible but the first two are very achievable and I am annoyed I didn\u0026rsquo;t think to just bring electrical tape to the lab and make a straight line for tuning.\nThe last thing is the line sensor is so close to the wheels that the PID needs to have higher than normal values to compensate for the short response time that\u0026rsquo;s needed. This isn\u0026rsquo;t as essential since we were able to run at 90% speed and most likely could have gotten that higher with more time spent tuning, but if it\u0026rsquo;s possible to move the line sensor forwards then do so.\nA fun bonus tip is to 3D print or buy a second wheel for the robot as they normally only had one and it makes it significantly more stable and accurate.\nVideo of our competition Links:\nCAD Model - Onshape\nDuckLaucher\n","permalink":"http://localhost:1313/posts/duck-launcher/","summary":"How we made the highest scoring duck launcher.","title":"Duck Launcher"},{"content":" Hardware ESP32-C3 Super Mini Force Sensitive Resistor (FSR) 10K ohm Resistor 3D-Printed Case As I often use ESP32-C3 Super Minis in a lot of my projects due to their extremely small size I had already designed a slim case for them which worked prefectly for this application. The case can be found here on my MakerWorld Profile Page.\nWiring The wiring was very simple, I just soldered one pin of the FSR to 3.3v and then the other pin to a analog pin, in my case pin 4, with the resistor connecting pin 4 and ground.\nSoftware Using Esphome I wrote a basic yaml code to publish a resistor value as well as a binary occupancy value to HomeAssistant that can be found here.\n","permalink":"http://localhost:1313/posts/bed-occupancy-sensor/","summary":"Low cost bed occupancy sensor made with an esp32-c3 super mini and a $10 resistor.","title":"Bed Occupancy Sensor"},{"content":" I wanted an automated blind solution that wouldn\u0026rsquo;t rely on cloud services or expensive commercial products. By repurposing an IKEA roller shades and designing my own controller system, I was able to build a cheap local solution.\nHardware The smart blind consists of four main components:\n28BYJ-48 stepper motor ULN2003 stepper motor driver board ESP32 microcontroller IKEA roller shade I chose these because they were very cheap off of Amazon or Aliexpress and because the ULN2003 was supported by Esphome\u0026rsquo;s stepper component which I was planning on using to program the esp32.\n3D-Printed Case To mount and house the motor and eletronics I designed a 3d printed case in Fusion360. This was my first time cading gears so it took me a bit to get the correct gear ration that would allow the motor to have enough torque to raise the blinds without skipping. After that it was just a matter of blocking out where each component would go and build the case around them.\nWiring The wiring for the ULN2003 was rather straight forward and only needed 4 wires connected to the esp32 and then power and ground for both the driver and esp32\nSoftware To test that everything was working I wrote a quick arduino program to spin the motor in both directions for a few seconds. After confirming my wiring was correct and the code ran I started to write the Esphome code. During this process, I discovered that RoadKillUK had published a Github that was very similar to what I was trying to accomplish. I only had to modify the code slightly to work with an esp32 but it was pretty much perfect.\nUsage \u0026amp; Future Improvements I\u0026rsquo;ve been running the blind for a little over a year now and have had no issue with it so far. There are a few things that I would change if I made a second version. First, the blinds are slow, they take over a minuet to raise/lower about 3 feet. Second, the stepper motor loses its memory of the blind position if it loses power and will need to be re-homed.\n","permalink":"http://localhost:1313/posts/smart-blinds-v1/","summary":"Cheap, simple and effective smart blinds made from and old IKEA roller shades and a few electronic components.","title":"Smart Blinds"},{"content":"I’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\nMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003eI’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\u003c/p\u003e\n\u003cp\u003eMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\u003c/p\u003e","title":"About"},{"content":" Duck Launcher Final At UCF every freshman engineering student is split into groups of four and tasked with designing and programming a TI-RSLK robot to score as many little rubber ducks in the \u0026ldquo;pond\u0026rdquo; as fast as possible by following a black line to the pond within 10 minutes.\nThe pond is a large pentagon in the middle of 5 tracks that teams are trying to score into. There are 3 zones in the pond, each getting progressively smaller and worth more points; 100, 300, and 500 respectively. There are also penalty cups closest to the black line that add a time penalty if hit, and bonus cups at the start line that can be hit on the way back for a 50 point bonus every time.\nDesign Our main design goal was to score in the 500 point section as quickly as possible. We really wanted to get cycle times to be as quick as possible since we were worried about the small size of the center 500 point ring filling up and preventing us from scoring all the points possible. Some constraints we had to follow were that the robot must be against the pond wall before shooting a duck and the motors on the robot were rather weak, making it essential we keep the weight of our mechanisms to a minimum. We also needed to hit the wall perfectly perpendicular to make aiming more accurate.\nAfter testing out several design archetypes we settled on a motorized lever arm. This allowed us to quickly shoot ducks as soon as we hit the wall of the pond and was overall a very lightweight and compact mechanism. To fix the aiming issue we added a front bumper that went over the front two bump switches that forced the robot to go flat against the wall. We ended up going through seven versions, tweaking various gear ratios and arm lengths before we finally settled on the model we used. Here is the link to the CAD for anyone interested: CAD Model - Onshape\nProgramming Every group was provided with very basic but working example code. However, this code was very messy and extremely slow which caused me to decide to rewrite it from scratch. One of the biggest issues with the example code is that they do not use a full PID, instead they just use a P value. While this works fine for the majority of robots, if you wanted to go faster than about 30% speed a true PID implementation is required.\nState Machine Architecture I structured the program around a state machine with six states: START, RESTART, PATH, SHOOT, TURN, and DONE. This made the code significantly cleaner and easier to debug which I will give credit to the example code for doing partially correct. Each state has its own dedicated function that handles exactly what needs to happen in that phase of the run.\nThe robot starts in START, waiting for a button press. Once triggered, it transitions to PATH where the line following happens. When the bump sensors detect the wall, it moves to SHOOT, fires the duck launcher mechanism, then enters TURN to do a 180-degree spin. After turning, it goes back to PATH to return home. On the second bump which is hitting the robot resetters hand for faster reset times, it transitions to DONE and waits for a restart by pressing the front bumper again.\nFull PID Implementation A proper PID controller is needed to consistently follow the line at faster speeds. The key improvement over the example code was using actual time deltas for the integral and derivative calculations rather than assuming a fixed loop time. We tuned our constants to KP = 0.05, KI = 0.001, and KD = 0.01 which allowed us to run at 90% motor speed while still tracking the line accurately. These values differed per robot as they all were in different states of disrepair so we were never able to tune the PID to be as smooth as I wanted.\nfloat dt = (currentTime - lastPIDTime) / 1000.0; // Convert to seconds int error = linePos - GOAL; float P = KP * error; integral += error * dt; integral = constrain(integral, -1000, 1000); // Anti-windup float I = KI * integral; float derivative = (error - lastError) / dt; float D = KD * derivative; float motor_speed_delta = P + I + D; The integral term includes anti-windup clamping to prevent it from accumulating too much error when the robot is off the line for extended periods. We also reset the PID state (error, integral, and timing) whenever transitioning between states to prevent any weird behavior from stale values.\nShooter Control The shooting mechanism was very simple, just a digital pin that triggers a relay to trigger the motorized lever arm. A quick HIGH pulse for 300ms is all it takes to launch a duck into the pond. I added small delays before and after to ensure clean activation and so that we don\u0026rsquo;t brownout the robot which was an issue we had when trying to run both the wheels and shooter motor at the same time.\nThe full code can be view here on my github: DuckLaucher\nIts not very pretty as a good bit of it was redone the day of the competition for a slight optimization in the PID. There is also a very basic score keeping webpage, its only slightly broken.\nRetrospective Overall we did great and I\u0026rsquo;m very proud of my team for coming first out of over two thousand freshman engineers! The average score was probably less than 2-3k which we crushed, scoring 30,500 points with 81 ducks (44 in the 500, 24 in the 300, and 13 in the 100).\nThere were a lot of cool and unique designs that I saw and we learned a lot about what works and what should be avoided. If we were to do this again there are several things we would change.\nFirst off, our fears of the center getting filled were confirmed, but not due to other teams—our cycles were so fast that the center was filled about 2-3 minutes into the competition. This caused a lot of ducks to bounce out of the center off of other ducks and land in the 100 and 300 point sections. We had nearly perfect accuracy so all the ducks from the score breakdown in the other sections are due to them bouncing out of the center. The best way to avoid this would probably be to fine tune the launch angle so that it either goes at a more downward angle to bounce up again or go at a very shallow angle so that the ducks hit the back wall of the 500 point zone and bounce inwards. This is similar to what our launcher did but it could be improved. Another way could be instead of launching the ducks, have a way to drop or place them in the center which would prevent them from bouncing out and make it so they can be stacked higher before completely filling it up.\nSecond, the PID tuning process could be improved. Ideally the PID should be tuned on a straight line at the weight of the final robot, and even better with the robot that is going to be used during the competition. Realistically the latter isn\u0026rsquo;t possible but the first two are very achievable and I am annoyed I didn\u0026rsquo;t think to just bring electrical tape to the lab and make a straight line for tuning.\nThe last thing is the line sensor is so close to the wheels that the PID needs to have higher than normal values to compensate for the short response time that\u0026rsquo;s needed. This isn\u0026rsquo;t as essential since we were able to run at 90% speed and most likely could have gotten that higher with more time spent tuning, but if it\u0026rsquo;s possible to move the line sensor forwards then do so.\nA fun bonus tip is to 3D print or buy a second wheel for the robot as they normally only had one and it makes it significantly more stable and accurate.\nVideo of our competition Links:\nCAD Model - Onshape\nDuckLaucher\nCompetition Video\n","permalink":"http://localhost:1313/posts/duck-launcher/","summary":"How we made the highest scoring duck launcher.","title":"Duck Launcher"},{"content":" Hardware ESP32-C3 Super Mini Force Sensitive Resistor (FSR) 10K ohm Resistor 3D-Printed Case As I often use ESP32-C3 Super Minis in a lot of my projects due to their extremely small size I had already designed a slim case for them which worked prefectly for this application. The case can be found here on my MakerWorld Profile Page.\nWiring The wiring was very simple, I just soldered one pin of the FSR to 3.3v and then the other pin to a analog pin, in my case pin 4, with the resistor connecting pin 4 and ground.\nSoftware Using Esphome I wrote a basic yaml code to publish a resistor value as well as a binary occupancy value to HomeAssistant that can be found here.\n","permalink":"http://localhost:1313/posts/bed-occupancy-sensor/","summary":"Low cost bed occupancy sensor made with an esp32-c3 super mini and a $10 resistor.","title":"Bed Occupancy Sensor"},{"content":" I wanted an automated blind solution that wouldn\u0026rsquo;t rely on cloud services or expensive commercial products. By repurposing an IKEA roller shades and designing my own controller system, I was able to build a cheap local solution.\nHardware The smart blind consists of four main components:\n28BYJ-48 stepper motor ULN2003 stepper motor driver board ESP32 microcontroller IKEA roller shade I chose these because they were very cheap off of Amazon or Aliexpress and because the ULN2003 was supported by Esphome\u0026rsquo;s stepper component which I was planning on using to program the esp32.\n3D-Printed Case To mount and house the motor and eletronics I designed a 3d printed case in Fusion360. This was my first time cading gears so it took me a bit to get the correct gear ration that would allow the motor to have enough torque to raise the blinds without skipping. After that it was just a matter of blocking out where each component would go and build the case around them.\nWiring The wiring for the ULN2003 was rather straight forward and only needed 4 wires connected to the esp32 and then power and ground for both the driver and esp32\nSoftware To test that everything was working I wrote a quick arduino program to spin the motor in both directions for a few seconds. After confirming my wiring was correct and the code ran I started to write the Esphome code. During this process, I discovered that RoadKillUK had published a Github that was very similar to what I was trying to accomplish. I only had to modify the code slightly to work with an esp32 but it was pretty much perfect.\nUsage \u0026amp; Future Improvements I\u0026rsquo;ve been running the blind for a little over a year now and have had no issue with it so far. There are a few things that I would change if I made a second version. First, the blinds are slow, they take over a minuet to raise/lower about 3 feet. Second, the stepper motor loses its memory of the blind position if it loses power and will need to be re-homed.\n","permalink":"http://localhost:1313/posts/smart-blinds-v1/","summary":"Cheap, simple and effective smart blinds made from and old IKEA roller shades and a few electronic components.","title":"Smart Blinds"},{"content":"I’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\nMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003eI’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\u003c/p\u003e\n\u003cp\u003eMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\u003c/p\u003e","title":"About"},{"content":" Duck Launcher Final At UCF every freshman engineering student is split into groups of four and tasked with designing and programming a TI-RSLK robot to score as many little rubber ducks in the \u0026ldquo;pond\u0026rdquo; as fast as possible by following a black line to the pond within 10 minutes.\nThe pond is a large pentagon in the middle of 5 tracks that teams are trying to score into. There are 3 zones in the pond, each getting progressively smaller and worth more points; 100, 300, and 500 respectively. There are also penalty cups closest to the black line that add a time penalty if hit, and bonus cups at the start line that can be hit on the way back for a 50 point bonus every time.\nDesign Our main design goal was to score in the 500 point section as quickly as possible. We really wanted to get cycle times to be as quick as possible since we were worried about the small size of the center 500 point ring filling up and preventing us from scoring all the points possible. Some constraints we had to follow were that the robot must be against the pond wall before shooting a duck and the motors on the robot were rather weak, making it essential we keep the weight of our mechanisms to a minimum. We also needed to hit the wall perfectly perpendicular to make aiming more accurate.\nAfter testing out several design archetypes we settled on a motorized lever arm. This allowed us to quickly shoot ducks as soon as we hit the wall of the pond and was overall a very lightweight and compact mechanism. To fix the aiming issue we added a front bumper that went over the front two bump switches that forced the robot to go flat against the wall. We ended up going through seven versions, tweaking various gear ratios and arm lengths before we finally settled on the model we used. Here is the link to the CAD for anyone interested: CAD Model - Onshape\nProgramming Every group was provided with very basic but working example code. However, this code was very messy and extremely slow which caused me to decide to rewrite it from scratch. One of the biggest issues with the example code is that they do not use a full PID, instead they just use a P value. While this works fine for the majority of robots, if you wanted to go faster than about 30% speed a true PID implementation is required.\nState Machine Architecture I structured the program around a state machine with six states: START, RESTART, PATH, SHOOT, TURN, and DONE. This made the code significantly cleaner and easier to debug which I will give credit to the example code for doing partially correct. Each state has its own dedicated function that handles exactly what needs to happen in that phase of the run.\nThe robot starts in START, waiting for a button press. Once triggered, it transitions to PATH where the line following happens. When the bump sensors detect the wall, it moves to SHOOT, fires the duck launcher mechanism, then enters TURN to do a 180-degree spin. After turning, it goes back to PATH to return home. On the second bump which is hitting the robot resetters hand for faster reset times, it transitions to DONE and waits for a restart by pressing the front bumper again.\nFull PID Implementation A proper PID controller is needed to consistently follow the line at faster speeds. The key improvement over the example code was using actual time deltas for the integral and derivative calculations rather than assuming a fixed loop time. We tuned our constants to KP = 0.05, KI = 0.001, and KD = 0.01 which allowed us to run at 90% motor speed while still tracking the line accurately. These values differed per robot as they all were in different states of disrepair so we were never able to tune the PID to be as smooth as I wanted.\nfloat dt = (currentTime - lastPIDTime) / 1000.0; // Convert to seconds int error = linePos - GOAL; float P = KP * error; integral += error * dt; integral = constrain(integral, -1000, 1000); // Anti-windup float I = KI * integral; float derivative = (error - lastError) / dt; float D = KD * derivative; float motor_speed_delta = P + I + D; The integral term includes anti-windup clamping to prevent it from accumulating too much error when the robot is off the line for extended periods. We also reset the PID state (error, integral, and timing) whenever transitioning between states to prevent any weird behavior from stale values.\nShooter Control The shooting mechanism was very simple, just a digital pin that triggers a relay to trigger the motorized lever arm. A quick HIGH pulse for 300ms is all it takes to launch a duck into the pond. I added small delays before and after to ensure clean activation and so that we don\u0026rsquo;t brownout the robot which was an issue we had when trying to run both the wheels and shooter motor at the same time.\nThe full code can be view here on my github: DuckLaucher\nIts not very pretty as a good bit of it was redone the day of the competition for a slight optimization in the PID. There is also a very basic score keeping webpage, its only slightly broken.\nRetrospective Overall we did great and I\u0026rsquo;m very proud of my team for coming first out of over two thousand freshman engineers! The average score was probably less than 2-3k which we crushed, scoring 30,500 points with 81 ducks (44 in the 500, 24 in the 300, and 13 in the 100).\nThere were a lot of cool and unique designs that I saw and we learned a lot about what works and what should be avoided. If we were to do this again there are several things we would change.\nFirst off, our fears of the center getting filled were confirmed, but not due to other teams—our cycles were so fast that the center was filled about 2-3 minutes into the competition. This caused a lot of ducks to bounce out of the center off of other ducks and land in the 100 and 300 point sections. We had nearly perfect accuracy so all the ducks from the score breakdown in the other sections are due to them bouncing out of the center. The best way to avoid this would probably be to fine tune the launch angle so that it either goes at a more downward angle to bounce up again or go at a very shallow angle so that the ducks hit the back wall of the 500 point zone and bounce inwards. This is similar to what our launcher did but it could be improved. Another way could be instead of launching the ducks, have a way to drop or place them in the center which would prevent them from bouncing out and make it so they can be stacked higher before completely filling it up.\nSecond, the PID tuning process could be improved. Ideally the PID should be tuned on a straight line at the weight of the final robot, and even better with the robot that is going to be used during the competition. Realistically the latter isn\u0026rsquo;t possible but the first two are very achievable and I am annoyed I didn\u0026rsquo;t think to just bring electrical tape to the lab and make a straight line for tuning.\nThe last thing is the line sensor is so close to the wheels that the PID needs to have higher than normal values to compensate for the short response time that\u0026rsquo;s needed. This isn\u0026rsquo;t as essential since we were able to run at 90% speed and most likely could have gotten that higher with more time spent tuning, but if it\u0026rsquo;s possible to move the line sensor forwards then do so.\nA fun bonus tip is to 3D print or buy a second wheel for the robot as they normally only had one and it makes it significantly more stable and accurate.\nVideo of our competition Links:\nCAD Model - Onshape\nDuckLaucher\nCompetition Video\n","permalink":"http://localhost:1313/posts/duck-launcher/","summary":"How we made the highest scoring duck launcher.","title":"Duck Launcher"},{"content":" Hardware ESP32-C3 Super Mini Force Sensitive Resistor (FSR) 10K ohm Resistor 3D-Printed Case As I often use ESP32-C3 Super Minis in a lot of my projects due to their extremely small size I had already designed a slim case for them which worked prefectly for this application. The case can be found here on my MakerWorld Profile Page.\nWiring The wiring was very simple, I just soldered one pin of the FSR to 3.3v and then the other pin to a analog pin, in my case pin 4, with the resistor connecting pin 4 and ground.\nSoftware Using Esphome I wrote a basic yaml code to publish a resistor value as well as a binary occupancy value to HomeAssistant that can be found here.\n","permalink":"http://localhost:1313/posts/bed-occupancy-sensor/","summary":"Low cost bed occupancy sensor made with an esp32-c3 super mini and a $10 resistor.","title":"Bed Occupancy Sensor"},{"content":" I wanted an automated blind solution that wouldn\u0026rsquo;t rely on cloud services or expensive commercial products. By repurposing an IKEA roller shades and designing my own controller system, I was able to build a cheap local solution.\nHardware The smart blind consists of four main components:\n28BYJ-48 stepper motor ULN2003 stepper motor driver board ESP32 microcontroller IKEA roller shade I chose these because they were very cheap off of Amazon or Aliexpress and because the ULN2003 was supported by Esphome\u0026rsquo;s stepper component which I was planning on using to program the esp32.\n3D-Printed Case To mount and house the motor and eletronics I designed a 3d printed case in Fusion360. This was my first time cading gears so it took me a bit to get the correct gear ration that would allow the motor to have enough torque to raise the blinds without skipping. After that it was just a matter of blocking out where each component would go and build the case around them.\nWiring The wiring for the ULN2003 was rather straight forward and only needed 4 wires connected to the esp32 and then power and ground for both the driver and esp32\nSoftware To test that everything was working I wrote a quick arduino program to spin the motor in both directions for a few seconds. After confirming my wiring was correct and the code ran I started to write the Esphome code. During this process, I discovered that RoadKillUK had published a Github that was very similar to what I was trying to accomplish. I only had to modify the code slightly to work with an esp32 but it was pretty much perfect.\nUsage \u0026amp; Future Improvements I\u0026rsquo;ve been running the blind for a little over a year now and have had no issue with it so far. There are a few things that I would change if I made a second version. First, the blinds are slow, they take over a minuet to raise/lower about 3 feet. Second, the stepper motor loses its memory of the blind position if it loses power and will need to be re-homed.\n","permalink":"http://localhost:1313/posts/smart-blinds-v1/","summary":"Cheap, simple and effective smart blinds made from and old IKEA roller shades and a few electronic components.","title":"Smart Blinds"},{"content":"I’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\nMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003eI’m a computer engineering student and developer with a focus on embedded systems, automation, and full-stack development. I enjoy designing efficient, practical solutions that bridge hardware and software — whether it\u0026rsquo;s building smart home systems, programming robots, or developing custom tools to streamline workflows.\u003c/p\u003e\n\u003cp\u003eMy work often combines rapid prototyping, custom electronics, 3D design, and software integration across multiple platforms. I aim to build projects that are not only functional but reliable, scalable, and maintainable.\u003c/p\u003e","title":"About"}]